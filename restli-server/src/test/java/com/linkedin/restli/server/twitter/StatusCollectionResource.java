/*
   Copyright (c) 2012 LinkedIn Corp.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

package com.linkedin.restli.server.twitter;

import com.linkedin.restli.common.EmptyRecord;
import com.linkedin.restli.common.PatchRequest;
import com.linkedin.restli.common.attachments.RestLiAttachmentReader;
import com.linkedin.restli.server.BatchCreateRequest;
import com.linkedin.restli.server.BatchCreateResult;
import com.linkedin.restli.server.BatchDeleteRequest;
import com.linkedin.restli.server.BatchFinderResult;
import com.linkedin.restli.server.BatchPatchRequest;
import com.linkedin.restli.server.BatchUpdateRequest;
import com.linkedin.restli.server.BatchUpdateResult;
import com.linkedin.restli.server.CreateResponse;
import com.linkedin.restli.server.PagingContext;
import com.linkedin.restli.server.ResourceLevel;
import com.linkedin.restli.server.UpdateResponse;
import com.linkedin.restli.server.altkey.AltStatusKeyCoercer;
import com.linkedin.restli.server.annotations.Action;
import com.linkedin.restli.server.annotations.ActionParam;
import com.linkedin.restli.server.annotations.AlternativeKey;
import com.linkedin.restli.server.annotations.BatchFinder;
import com.linkedin.restli.server.annotations.Finder;
import com.linkedin.restli.server.annotations.Optional;
import com.linkedin.restli.server.annotations.PagingContextParam;
import com.linkedin.restli.server.annotations.QueryParam;
import com.linkedin.restli.server.annotations.RestLiAttachmentsParam;
import com.linkedin.restli.server.annotations.RestLiCollection;
import com.linkedin.restli.server.resources.CollectionResourceTemplate;
import com.linkedin.restli.server.twitter.TwitterTestDataModels.Status;
import com.linkedin.restli.server.twitter.TwitterTestDataModels.StatusType;

import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * CollectionResource containing all statuses
 *
 * @author dellamag
 */
@AlternativeKey(name="alt", keyCoercer = AltStatusKeyCoercer.class, keyType = String.class)
@RestLiCollection(name="statuses",
                    keyName="statusID")
public class StatusCollectionResource extends CollectionResourceTemplate<Long,Status>
{
  /**
   * Gets a sample of the timeline of statuses generated by all users
   */
  @Finder("public_timeline")
  public List<Status> getPublicTimeline(@PagingContextParam PagingContext pagingContext)
  {
    return null;
  }

  /**
   * Gets the status timeline for a given user
   */
  @Finder("user_timeline")
  public List<Status> getUserTimeline(@Optional("true") @QueryParam("includeReplies") Boolean includeReplies, @PagingContextParam(defaultCount = 100, defaultStart = 10) PagingContext pagingContext)
  {
    return null;
  }

  /**
   * Keyword search for statuses
   *
   * @param keywords keywords to search for
   * @param since a unix timestamp. If present, only statuses created after this time are returned
   */
  @Finder("search")
  public List<Status> search(@QueryParam("keywords") String keywords,
                             @QueryParam("since") @Optional("-1") long since,
                             @QueryParam("type") @Optional StatusType type)
  {
    return null;
  }

  /** * find status by a parameter named "action"
   *
   */
  @Finder("findByAction")
  public List<Status> findByAction(@QueryParam("action") String  actionName,
      @QueryParam("bq") String bqParameterValue
  )
  {
    return null;
  }

  /** * Batchfinder by a parameter named "action"
   *    This is an invalid method since the parameter name cannot be named "q"
   *    in batchFinder
   */
  @BatchFinder(value="batchFinderByAction",  batchParam="action")
  public BatchFinderResult<Status, Status, EmptyRecord> batchFinderByAction(
      @QueryParam("action") Status[]  actionNames,
      @QueryParam("q") @Optional String qParam
  )
  {
    return null;
  }

  /**
   * Creates a new Status
   */
  @Override
  public CreateResponse create(Status entity)
  {
    return null;
  }

  /**
   * Gets a batch of statuses
   */
  @Override
  public Map<Long, Status> batchGet(Set<Long> ids)
  {
    return null;
  }

  /**
   * Gets a single status resource
   */
  @Override
  public Status get(Long key)
  {
    return null;
  }

  /**
   * Deletes a status resource
   */
  @Override
  public UpdateResponse delete(Long key)
  {
    return null;
  }

  /**
   * Partially updates a single status resource
   */
  @Override
  public UpdateResponse update(Long key, PatchRequest<Status> request)
  {
    return null;
  }

  /**
   * Updates (overwrites) a single status resource
   */
  @Override
  public UpdateResponse update(Long key, Status entity)
  {
    return null;
  }

  @Override
  public BatchUpdateResult<Long, Status> batchUpdate(
          BatchUpdateRequest<Long, Status> entities)
  {
    return null;
  }

  @Override
  public BatchUpdateResult<Long, Status> batchUpdate(
          BatchPatchRequest<Long, Status> entityUpdates)
  {
    return null;
  }

  @Override
  public BatchCreateResult<Long, Status> batchCreate(
          BatchCreateRequest<Long, Status> entities)
  {
    return null;
  }

  @Override
  public BatchUpdateResult<Long, Status> batchDelete(
          BatchDeleteRequest<Long, Status> ids)
  {
    return null;
  }

  /**
   * Ambiguous action binding test case
   */
  @Action(name="forward",
          resourceLevel = ResourceLevel.ENTITY)
  public void forward(@ActionParam("to") long userID)
  {
  }

  @Action(name="streamingAction",
          resourceLevel = ResourceLevel.COLLECTION)
  public Long streamingAction(@ActionParam("metadata") String metadata,
                              @RestLiAttachmentsParam RestLiAttachmentReader attachmentReader)
  {
    return null;
  }
}
