<!DOCTYPE html>
<html lang="en">

  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0"/>

    <title>Developer guide</title>
    <meta name="description" content="A REST framework for building scalable service architectures using dynamic discovery and simple asynchronous APIs" />

    <link rel="icon" 
      type="image/png" 
      href="/images/icon_pegasus.png">
  
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" type="text/css" media="screen,projection" href="/assets/materialize.css" />
    <link rel="stylesheet" type="text/css" media="screen,projection" href="/assets/main.css">
    <link rel="canonical" href="http://localhost:4000/user_guide/restli_client" />
    <link rel="alternate" type="application/rss+xml" title="rest.li" href="/feed.xml" />
  
    
</head>


  <body>

    <nav class="dark-grey" role="navigation">
    <div class="nav-wrapper container"><a id="logo-container" class="brand-logo" href="/">Rest.li</a>


          <ul class="right hide-on-med-and-down">
               
      
        <li>
          <a href="/rest.li/get_started/quick_start" >
            Getting Started
          </a>
        </li>
        
        <li>
          <a href="/rest.li/user_guide/server_architecture" >
            User guide
          </a>
        </li>
        
        <li>
          <a href="https://github.com/linkedin/rest.li/wiki" >
            Wiki
          </a>
        </li>
        
        <li>
          <a href="/rest.li/contribute/howto" >
            Contribute
          </a>
        </li>
        
          </ul>


      <a href="#" data-activates="nav-mobile" class="button-collapse"><i class="material-icons">menu</i></a>
    </div>
</nav>


        <div class="container">
        <div class="row">
                <div class="col s12 m4 l3"> 
               
                    
                   
                    
                     <ul class="nav_items">
                        <li><span class="nav_sub-title">User Guide</span></li>
                        <ul>
                       
                         <li><a href="/rest.li/user_guide/server_architecture">Rest.li Architecture</a></li>
                       
                         <li><a href="/rest.li/user_guide/restli_server">Rest.li Server</a></li>
                       
                         <li><a href="/rest.li/user_guide/restli_client">Rest.li Client Framework</a></li>
                       
                        </ul>
                     </ul>
                        
                   
                    
                     <ul class="nav_items">
                        <li><span class="nav_sub-title">Spec</span></li>
                        <ul>
                       
                         <li><a href="/rest.li/spec/protocol">Rest.li Protocol</a></li>
                       
                         <li><a href="/rest.li/spec/restspec_format">Restspec json format</a></li>
                       
                        </ul>
                     </ul>
                        
                   
                    
                     <ul class="nav_items">
                        <li><span class="nav_sub-title">Modeling Resources</span></li>
                        <ul>
                       
                         <li><a href="/rest.li/modeling/modeling">Modeling Resources</a></li>
                       
                         <li><a href="/rest.li/modeling/compatibiltiy_check">Snapshots and Resource Compatibility Checking</a></li>
                       
                        </ul>
                     </ul>
                        
                    </div>
                     <div class="markdown-body col s12 m3 l9">
                            <h1 id="restli-client-framework">Rest.li Client Framework</h1>
<hr />

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#depending-on-a-services-client-bindings">Depending on a Service’s Client
Bindings</a></li>
  <li><a href="#depending-on-data-templates">Depending on Data Templates</a></li>
  <li><a href="#type-safe-builders">Type-Safe Builders</a></li>
  <li><a href="#built-in-request-and-requestbuilder-classes">Built-in Request and RequestBuilder
classes</a></li>
  <li><a href="#restspec-idl">Restspec IDL</a></li>
  <li><a href="#restclient">RestClient</a></li>
  <li><a href="#request-options">Request Options</a></li>
  <li><a href="#parseq-integrated-rest-client">ParSeq Integrated Rest Client</a></li>
  <li><a href="#client-code-generator-tool">Client Code Generator Tool</a></li>
  <li><a href="#restli-extras">Rest.li-extras</a></li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>The Rest.li client framework provides support for accessing resources
defined using Rest.li. The client framework consists of two parts:</p>

<ul>
  <li><code>RequestBuilder</code> classes, which provide an interface for
creating REST requests to access a specific method of a resource.
Request builders work entirely in-memory and do not communicate with
remote endpoints.</li>
  <li><code>RestClient</code>, which provides an interface for sending
requests to remote endpoints and receiving responses.</li>
</ul>

<p>The request builder portion of the framework can be further divided into
two layers:</p>

<ul>
  <li>Built-in request builder classes, which provide generic support for
accessing Rest.li resources. The built-in request builders
understand how to construct requests for the different Rest.li
resource methods, but they do not have knowledge of any specific
resources or the methods they support. Therefore, the built-in
request builders cannot validate that a request will be supported by
the remote endpoint.</li>
  <li>Type-safe request builder classes, which are generated from the
server resource’s IDL. The type-safe request builders are tailored
to the specific resource methods supported by each resource. The
type-safe builders provide an API that guides the developer towards
constructing valid requests.</li>
</ul>

<p>Most developers should work with the type-safe request builders, unless
there is a specific need to work with arbitrary resources whose
interfaces are unknown at the time the code is written.</p>

<p><a id="wiki-CLientBindings"></a></p>

<h2 id="depending-on-a-services-client-bindings">Depending on a Service’s Client Bindings</h2>

<p>Usually, developers building Rest.li services publish Java client
bindings for the Rest.li resources their service provides as artifacts
into a shared repository, such as a maven repo. By adding a dependency
to these artifacts, other developers can quickly get their hands on the
request builder classes defined in these client bindings to make
requests to the resources provided by that service.</p>

<p>To add a dependency from a gradle project, add the artifact containing
the rest client bindings to your dependency list. If you are unsure of
the name of the artifact, ask the service owners. They are usually the
artifact with a name ending in -client, -api or -rest. Note that the
<a href="http://gradle.org/docs/current/userguide/dependency_management.html#sec:dependency_configurations">configuration</a>
for the dependency must be set to <code>restClient</code>:</p>

<p>build.gradle:\
```groovy\
…\
﻿dependencies {\
// for a local project:\
compile project(path: ‘:example-api’, configuration: ‘restClient’)\
// for a versioned artifact:\
compile group: ‘org.somegroup’, name: ‘example-api’, version: ‘1.0’,
configuration: ‘restClient’\
}\
…\
```</p>

<p><a id="wiki-DataTemplates"></a></p>

<h2 id="depending-on-data-templates">Depending on Data Templates</h2>

<p>To add a dependency to Java bindings for data models, add a
<code>dataTemplate</code> configured dependency in your build.gradle,
for example:</p>

<p>build.gradle:\
```groovy\
…\
﻿dependencies {\
// for a local project:\
compile project(path: ‘:example-api’, configuration: ‘dataTemplate’)\
// for a versioned artifact:\
compile group: ‘org.somegroup’, name: ‘example-api’, version: ‘1.0’,
configuration: ‘dataTemplate’\
}\
…\
```</p>

<p>Note that you should not usually need to add such a dependency when
adding a <code>restClient</code> dependency, as the
<code>restClient</code> should bring in the <code>dataTemplate</code>
transitively.</p>

<p>Note: If you are writing pegasus schemas (.pdsc files) and need to add a
dependency on other pegasus schemas, you need to add a
<code>dataModel</code> dependency:</p>

<p>build.gradle\
```groovy\
…\
dataModel spec.product.example.data\
…\
```</p>

<p><a id="wiki-Builders"></a></p>

<h2 id="type-safe-builders">Type-Safe Builders</h2>

<p>The client framework includes a code-generation tool that reads the IDL
and generates type-safe Java binding for each resource and its supported
methods. The bindings are represented as RequestBuilder classes.</p>

<p><a id="wiki-BuilderFactories"></a></p>

<h3 id="resource-builder-factory">Resource Builder Factory</h3>

<p>For each resource described in an IDL file, a corresponding builder
factory will be generated. For Rest.li version &lt; 1.24.4, the builder
factory will be named <code class="highlighter-rouge">&lt;Resource name&gt;Builders</code>. For Rest.li version &gt;=
1.24.4, the builder factory is named <code class="highlighter-rouge">&lt;Resource name&gt;RequestBuilders</code>.
The factory contains a factory method for each resource method supported
by the resource. The factory method returns a request builder object
with type-safe bindings for the given method.</p>

<p>Standard CRUD methods are named <code class="highlighter-rouge">create()</code>, <code class="highlighter-rouge">get()</code>, <code class="highlighter-rouge">update()</code>,
<code class="highlighter-rouge">partialUpdate()</code>, <code class="highlighter-rouge">delete()</code>, and <code class="highlighter-rouge">batchGet()</code>. Action methods use the
name of the action, prefixed by “action”, <code class="highlighter-rouge">action&lt;ActionName&gt;()</code>. Finder
methods use the name of the finder, prefixed by “findBy”,
<code class="highlighter-rouge">findBy&lt;FinderName&gt;()</code>.</p>

<p>An example for a resource named “Greetings” is shown below. Here is the
builder factory for Rest.li &lt; 1.24.4:</p>

<p>```java\
public class GreetingsBuilders {\
public GreetingsBuilders()\
public GreetingsBuilders(String primaryResourceName)\
public GreetingsCreateBuilder create()\
public GreetingsGetBuilder get()\
public GreetingsUpdateBuilder update()\
public GreetingsPartialUpdateBuilder partialUpdate()\
public GreetingsDeleteBuilder delete()\
public GreetingsBatchGetBuilder batchGet()\
public GreetingsBatchCreateBuilder batchCreate()\
public GreetingsBatchUpdateBuilder batchUpdate()\
public GreetingsBatchPartialUpdateBuilder batchPartialUpdate()\
public GreetingsBatchDeleteBuilder batchDelete()\
public GreetingsDoSomeActionBuilder actionSomeAction()\
public GreetingsFindBySearchBuilder findBySearch()\
}\
```</p>

<p>Here is the builder factory for Rest.li &gt;= 1.24.4:</p>

<p>```java\
public class GreetingsRequestBuilders extends BuilderBase {\
public GreetingsRequestBuilders()\
public GreetingsRequestBuilders(String primaryResourceName)\
public GreetingsCreateRequestBuilder create()\
public GreetingsGetRequestBuilder get()\
public GreetingsUpdateRequestBuilder update()\
public GreetingsPartialUpdateRequestBuilder partialUpdate()\
public GreetingsDeleteRequestBuilder delete()\
public GreetingsBatchGetRequestBuilder batchGet()\
public GreetingsBatchCreateRequestBuilder batchCreate()\
public GreetingsBatchUpdateRequestBuilder batchUpdate()\
public GreetingsBatchPartialUpdateRequestBuilder batchPartialUpdate()\
public GreetingsBatchDeleteRequestBuilder batchDelete()\
public GreetingsDoSomeActionRequestBuilder actionSomeAction()\
public GreetingsFindBySearchRequestBuilder findBySearch()\
}\
```</p>

<h3 id="get-request-builder">GET Request Builder</h3>

<p>In Rest.li &lt; 1.24.4, the generated GET request builder for a resource
is named <code class="highlighter-rouge">&lt;Resource&gt;GetBuilder</code>. In Rest.li &gt;= 1.24.4, the generated
GET request builder is named <code class="highlighter-rouge">&lt;Resource&gt;GetRequestBuilder</code>. Both support
the full interface of the built-in <code class="highlighter-rouge">GetRequestBuilder</code>.</p>

<p>If the resource class is a child resource, the generated builder will
include a type-safe path-key binding method for each of the resource’s
ancestors (recursively following parent resources). Each binding method
is declared as:\
```java\
public <BuilderType> <pathKeyName>Key(<KeyType> key);\
\`\`\`\
e.g., for a parent pathKey named "groupId" of type `Integer` in the
"Contacts" resource, the binding method in Rest.li \&lt; 1.24.4 would be:\
\`\`\`java\
public ContactsGetBuilder groupIdKey(Integer key)\
\`\`\`</KeyType></pathKeyName></BuilderType></p>

<p>In Rest.li &gt;= 1.24.4, it would be:\
```java\
public ContactsGetRequestBuilder groupIdKey(Integer key)\
```</p>

<h3 id="batch_get-request-builder">BATCH_GET Request Builder</h3>

<p>In Rest.li &lt; 1.24.4, the generated BATCH_GET request builder for a
resource is named <code class="highlighter-rouge">&lt;Resource&gt;BatchGetBuilder</code>. The generated builder
supports the full interface of the built-in <code class="highlighter-rouge">BatchGetRequestBuilder</code>.</p>

<p>In Rest.li &gt;= 1.24.4, the generated BATCH_GET request builder for a
resource is named <code class="highlighter-rouge">&lt;Resource&gt;BatchGetRequestBuilder</code>. The generated
builder extends the built-in <code class="highlighter-rouge">BatchGetEntityRequestBuilder</code>.</p>

<p>When building requests with <code class="highlighter-rouge">BatchGetRequestBuilder</code>, use the
<code class="highlighter-rouge">buildKV()</code> method (<code class="highlighter-rouge">build()</code> is deprecated), for example:\
```java\
new FortunesBuilders().batchGet().ids(…).buildKV()\
```</p>

<p>When building requests with the <code class="highlighter-rouge">BatchGetEntityRequestBuilder</code>, the
<code class="highlighter-rouge">build()</code> method is used.</p>

<p>If the resource class is a child resource, the generated builder will
include a type-safe path-key binding method for each of the resource’s
ancestors (recursively following parent resources). Each binding method
is declared as:\
```java\
public <BuilderType> <pathKeyName>Key(<KeyType> key);\
\`\`\`\
For example, a parent pathKey named "groupId" of type `Integer` in the
"Contacts" resource will have the binding method in Rest.li \&lt; 1.24.4 be
this:\
\`\`\`java\
public ContactsBatchGetBuilder groupIdKey(Integer key)\
\`\`\`</KeyType></pathKeyName></BuilderType></p>

<p>In Rest.li &gt;= 1.24.4, it would be:\
```java\
public ContactsBatchGetRequestBuilder groupIdKey(Integer key)\
```</p>

<h3 id="finder-request-builder">FINDER Request Builder</h3>

<p>In Rest.li &lt; 1.24.4, the generated FINDER request builder for a
resource is named <code class="highlighter-rouge">&lt;Resource&gt;FindBy&lt;FinderName&gt;Builder</code>, while in
Rest.li &gt;= 1.24.4 it is named
<code class="highlighter-rouge">&lt;Resource&gt;FindBy&lt;FinderName&gt;RequestBuilder</code>. Both builders support the
full interface of the built-in <code class="highlighter-rouge">FindRequestBuilder</code>.</p>

<p>If the resource class is a child resource, the generated builder will
include a type-safe path-key binding method for each of the resource’s
ancestors (recursively following parent resources). Each binding method
is declared as:\
```java\
public <BuilderType> <pathKeyName>Key(<KeyType> key);\
\`\`\`</KeyType></pathKeyName></BuilderType></p>

<p>The generated builder will contain a method to set each of the finder’s
query parameters, of the form:\
```java\
public <BuilderType> <paramName>Param(<ParamType> value);\
\`\`\`</ParamType></paramName></BuilderType></p>

<p>The value <strong>must</strong> be non-null.</p>

<p>If the finder specifies <code class="highlighter-rouge">AssocKey</code> parameters, the builder will contain
a method to set each of them, of the form:\
```java\
public <BuilderType> <assocKeyName>Key(<AssocKeyType> value);\
\`\`\`</AssocKeyType></assocKeyName></BuilderType></p>

<h3 id="create-request-builder">CREATE Request Builder</h3>

<p>In Rest.li &lt; 1.24.4, the generated CREATE request builder for a
resource is named <code class="highlighter-rouge">&lt;Resource&gt;CreateBuilder</code>. The generated builder
supports the full interface of the built-in <code class="highlighter-rouge">CreateRequestBuilder</code>.</p>

<p>In Rest.li &gt;= 1.24.4, the generated CREATE request builder for a
resource is named <code class="highlighter-rouge">&lt;Resource&gt;CreateRequestBuilder</code>. The generated
builder extends the built-in <code class="highlighter-rouge">CreateIdRequestBuilder</code>.</p>

<p>If the resource class is a child resource, the generated builder will
include a type-safe path-key binding method for each of the resource’s
ancestors (recursively following parent resources). Each binding method
is declared as:\
```java\
public <BuilderType> <pathKeyName>Key(<KeyType> key);\
\`\`\`</KeyType></pathKeyName></BuilderType></p>

<p>If @<code class="highlighter-rouge">ReturnEntity</code> annotation is specified for CREATE implementation, an
additional <code class="highlighter-rouge">CreateAndGet</code> request builder will be generated. Note that
<code class="highlighter-rouge">Create</code> request builder is still available so that adding
@<code class="highlighter-rouge">ReturnEntity</code> is backward compatible for a Java client.\
```java\
public class <Resource>RequestBuilders\
{\
...\
public <Resource>CreateRequestBuilder create();\
public <Resource>CreateAndGetRequestBuilder createAndGet();\
...\
}\
\`\`\`\
The response will be of type `IdEntityResponse&lt;K, V&gt;` which has a
`getEntity()` method:\
\`\`\`java\
...\
// "greeting" is defined in previous context\
CreateIdEntityRequest\&lt;Long, Greeting\&gt; createIdEntityRequest =
builders.createAndGet().input(greeting).build();\
Response\&lt;IdEntityResponse\&lt;Long, Greeting\&gt;\&gt; response =
restClient.sendRequest(createIdEntityRequest).getResponse();\
...\
IdEntityResponse\&lt;Long, Greeting\&gt; idEntityResponse =
response.getEntity();\
// The returned entity from server\
Greeting resultEntity = idEntityResponse.getEntity();\
\`\`\`</Resource></Resource></Resource></p>

<p>The projection for returned entity is supported.\
```java\
…\
// “greeting” is defined in previous context\
CreateIdEntityRequest&lt;Long, Greeting&gt; createIdEntityRequest =
builders.createAndGet().fields(Greeting.fields().tone(),
Greeting.fields().id()).input(greeting).build();\
```</p>

<h3 id="batch_create-request-builder">BATCH_CREATE Request Builder</h3>

<p>In Rest.li &lt; 1.24.4, the generated BATCH_CREATE request builder for a
resource is named <code class="highlighter-rouge">&lt;Resource&gt;BatchCreateBuilder</code>. The generated builder
supports the full interface of the built-in <code class="highlighter-rouge">BatchCreateRequestBuilder</code>.</p>

<p>In Rest.li &gt;= 1.24.4, the generated BATCH_CREATE request builder for a
resource is named <code class="highlighter-rouge">&lt;Resource&gt;BatchCreateRequestBuilder</code>. The generated
builder extends the built-in <code class="highlighter-rouge">BatchCreateIdRequestBuilder</code>.</p>

<p>If the resource class is a child resource, the generated builder will
include a type-safe path-key binding method for each of the resource’s
ancestors (recursively following parent resources). Each binding method
is declared as:\
```java\
public <BuilderType> <pathKeyName>Key(<KeyType> key);\
\`\`\`</KeyType></pathKeyName></BuilderType></p>

<p>If @<code class="highlighter-rouge">ReturnEntity</code> annotation is specified for BATCH_CREATE
implementation, an additional <code class="highlighter-rouge">BatchCreateAndGet</code> request builder will
be generated. Note that <code class="highlighter-rouge">BatchCreate</code> request builder will still be
generated so that adding @<code class="highlighter-rouge">ReturnEntity</code> annotation is backward
compatible for a Java client.\
```java\
public class <Resource>RequestBuilders\
{\
...\
public <Resource>BatchCreateRequestBuilder batchCreate();\
public <Resource>BatchCreateAndGetRequestBuilder batchCreateAndGet();\
...\
}\
\`\`\`</Resource></Resource></Resource></p>

<p>The response will be of type <code class="highlighter-rouge">BatchCreateIdEntityResponse</code> whose
elements are <code class="highlighter-rouge">CreateIdEntityStatus</code> object containing the returned
entity. Here is a code example.\
```java\
…\
// “greetings” is defined in previous context\
BatchCreateIdEntityRequest&lt;Long, Greeting&gt; batchCreateIdEntityRequest
= builders.batchCreateAndGet().inputs(greetings).build();\
Response&lt;BatchCreateIdEntityResponse&lt;Long, Greeting&gt;&gt; response =
restClient.sendRequest(batchCreateIdEntityRequest).getResponse();\
BatchCreateIdEntityResponse&lt;Long, Greeting&gt; entityResponses =
response.getEntity();\
for (CreateIdEntityStatus&lt;?, ?&gt; individualResponse :
entityResponses.getElements())\
{\
Greeting entity = (Greeting)individualResponse.getEntity();// The
returned individual entity from server\
}\
```\
The projection for returned entities is supported.\
```java\
…\
// “greetings” is defined as a list of greeting in previous context\
BatchCreateIdEntityRequest&lt;Long, Greeting&gt; batchCreateIdEntityRequest
= builders.batchCreateAndGet().fields(Greeting.fields().tone(),
Greeting.fields().id()).inputs(greetings).build();\
```</p>

<h3 id="partial_update-request-builder">PARTIAL_UPDATE Request Builder</h3>

<p>In Rest.li &lt; 1.24.4, the generated PARTIAL_UPDATE request builder for
a resource is named <code class="highlighter-rouge">&lt;Resource&gt;PartialUpdateBuilder</code>. Whereas in Rest.li
&gt;= 1.24.4, it is called <code class="highlighter-rouge">&lt;Resource&gt;PartialUpdateRequestBuilder</code>. Both
builders support the full interface of the built-in
<code class="highlighter-rouge">PartialUpdateRequestBuilder</code>.</p>

<p>If the resource class is a child resource, the generated builder will
include a type-safe path-key binding method for each of the resource’s
ancestors (recursively following parent resources). Each binding method
is declared as:\
```java\
public <BuilderType> <pathKeyName>Key(<KeyType> key);\
\`\`\`</KeyType></pathKeyName></BuilderType></p>

<p>See <a href="https://github.com/linkedin/rest.li/wiki/Rest.li-User-Guide#wiki-creating-partial-updates">Creating partial
updates</a>
for details on how to create a request for a partial update.</p>

<h3 id="batch_partial_update-request-builder">BATCH_PARTIAL_UPDATE Request Builder</h3>

<p>In Rest.li &lt; 1.24.4, the generated BATCH_PARTIAL_UPDATE request
builder for a resource is named <code class="highlighter-rouge">&lt;Resource&gt;BatchPartialUpdateBuilder</code>.
Whereas in Rest.li &gt;= 1.24.4, it is
<code class="highlighter-rouge">&lt;Resource&gt;BatchPartialUpdateRequestBuilder</code>. Both support the full
interface of the built-in <code class="highlighter-rouge">BatchPartialUpdateRequestBuilder</code>.</p>

<p>If the resource class is a child resource, the generated builder will
include a type-safe path-key binding method for each of the resource’s
ancestors (recursively following parent resources). Each binding method
is declared as:\
```java\
public <BuilderType> <pathKeyName>Key(<KeyType> key);\
\`\`\`</KeyType></pathKeyName></BuilderType></p>

<h3 id="update-request-builder">UPDATE Request Builder</h3>

<p>In Rest.li &lt; 1.24.4, the generated UPDATE request builder for a
resource is named <code class="highlighter-rouge">&lt;Resource&gt;UpdateBuilder</code>. Whereas in Rest.li &gt;=
1.24.4, it is named <code class="highlighter-rouge">&lt;Resource&gt;UpdateRequestBuilder</code>. Both builders
support the full interface of the built-in <code class="highlighter-rouge">UpdateRequestBuilder</code>.</p>

<p>If the resource class is a child resource, the generated builder will
include a type-safe path-key binding method for each of the resource’s
ancestors (recursively following parent resources). Each binding method
is declared as:\
```java\
public <BuilderType> <pathKeyName>Key(<KeyType> key);\
\`\`\`</KeyType></pathKeyName></BuilderType></p>

<h3 id="batch_update-request-builder">BATCH_UPDATE Request Builder</h3>

<p>In Rest.li &lt; 1.24.4, the generated BATCH_UPDATE request builder for a
resource is named <code class="highlighter-rouge">&lt;Resource&gt;BatchUpdateBuilder</code>. Whereas in Rest.li &gt;=
1.24.4, it is named <code class="highlighter-rouge">&lt;Resource&gt;BatchUpdateRequestBuilder</code>. Both builders
support the full interface of the built-in <code class="highlighter-rouge">BatchUpdateRequestBuilder</code>.</p>

<p>If the resource class is a child resource, the generated builder will
include a type-safe path-key binding method for each of the resource’s
ancestors (recursively following parent resources). Each binding method
is declared as:\
```java\
public <BuilderType> <pathKeyName>Key(<KeyType> key);\
\`\`\`</KeyType></pathKeyName></BuilderType></p>

<h3 id="delete-request-builder">DELETE Request Builder</h3>

<p>The generated DELETE request builder for a resource is named
<code class="highlighter-rouge">&lt;Resource&gt;DeleteBuilder</code>. The generated builder supports the full
interface of the built-in <code class="highlighter-rouge">DeleteRequestBuilder</code>.</p>

<p>If the resource class is a child resource, the generated builder will
include a type-safe path-key binding method for each of the resource’s
ancestors (recursively following parent resources). Each binding method
is declared as:\
```java\
public <BuilderType> <pathKeyName>Key(<KeyType> key);\
\`\`\`</KeyType></pathKeyName></BuilderType></p>

<h3 id="batch_delete-request-builder">BATCH_DELETE Request Builder</h3>

<p>In Rest.li &lt; 1.24.4, the generated BATCH_DELETE request builder for a
resource is named <code class="highlighter-rouge">&lt;Resource&gt;BatchDeleteBuilder</code>. Whereas in Rest.li &gt;=
1.24.4, the builder is called <code class="highlighter-rouge">&lt;Resource&gt;BatchDeleteRequestBuilder</code>.
Both builders support the full interface of the built-in
<code class="highlighter-rouge">BatchDeleteRequestBuilder</code>.</p>

<p>If the resource class is a child resource, the generated builder will
include a type-safe path-key binding method for each of the resource’s
ancestors (recursively following parent resources). Each binding method
is declared as:\
```java\
public <BuilderType> <pathKeyName>Key(<KeyType> key);\
\`\`\`</KeyType></pathKeyName></BuilderType></p>

<h3 id="action-request-builder">ACTION Request Builder</h3>

<p>In Rest.li &lt; 1.24.4, the generated ACTION request builder for a
resource is named <code class="highlighter-rouge">&lt;Resource&gt;Do&lt;ActionName&gt;Builder</code>. Whereas in Rest.li
&gt;= 1.24.4, it is <code class="highlighter-rouge">&lt;Resource&gt;Do&lt;ActionName&gt;RequestBuilder</code>. Both
builders support the full interface of the built-in
<code class="highlighter-rouge">ActionRequestBuilder</code>.</p>

<p>If the resource class is a child resource, the generated builder will
include a type-safe path-key binding method for each of the resource’s
ancestors (recursively following parent resources). Each binding method
is declared as:\
```java\
public <BuilderType> <pathKeyName>Key(<KeyType> key);\
\`\`\`</KeyType></pathKeyName></BuilderType></p>

<p>The generated builder will contain a method to set each of the action’s
parameters. It Rest.li &lt; 1.24.4, it is of the form:\
```java\
public <BuilderType> param<ParamName>(<ParamType> value);\
\`\`\`</ParamType></ParamName></BuilderType></p>

<p>In Rest.li &gt;= 1.24.4, it is of the form:\
```java\
public <BuilderType> <paramName>Param(<ParamType> value);\
\`\`\`</ParamType></paramName></BuilderType></p>

<p>The value <strong>must</strong> be non-null.</p>

<p><a id="wiki-CallingSubResources"></a></p>

<h3 id="calling-sub-resources">Calling Sub-Resources</h3>

<p>To call a subresource of the fortunes resource, for example:</p>

<p>```\
GET /fortunes/1/subresource/100\
```</p>

<p>The parent keys can be specified by calling generated setters on the
builder. In this case, the <code class="highlighter-rouge">fortunesIdKey()</code> method, for example:</p>

<p>```java\
new SubresourceBuilders().get().fortunesIdKey(1l).id(100l).build()\
```</p>

<p>Parent path keys can also be set directly builder classes using the
<code class="highlighter-rouge">setPathKey()</code> method on the builders classes, for example:</p>

<p>```java\
.setPathKey(“dest”, “dest”).setPathKey(“src”, “src”)\
```</p>

<p><a id="wiki-BuiltinRequestBuilders"></a></p>

<h2 id="built-in-request-and-requestbuilder-classes">Built-in Request and RequestBuilder classes</h2>

<p>The built-in RequestBuilder classes provide generic support for
constructing Rest.li requests. This layer is independent of the IDL for
specific resources; therefore, the interface does not enforce that only
“valid” requests are constructed.</p>

<p>There is one RequestBuilder subclass for each of the Rest.li resource
methods. Each RequestBuilder provides a <code class="highlighter-rouge">.build()</code> method that
constructs a <code class="highlighter-rouge">Request</code> object that can be used to invoke the
corresponding resource method. Each RequestBuilder constructs the
<code class="highlighter-rouge">Request</code> subclass that corresponds to the Rest.li method, for example,
<code class="highlighter-rouge">BatchGetRequestBuilder.build()</code> returns a <code class="highlighter-rouge">BatchGetRequest</code>. The
<code class="highlighter-rouge">Request</code> subclasses allow framework code to introspect the original
type and parameters for a given request.</p>

<p>Each RequestBuilder class supports a subset of the following methods, as
appropriate for the corresponding resource method:</p>

<ul>
  <li><code class="highlighter-rouge">header(String key, String value)</code> - sets a request header</li>
  <li><code class="highlighter-rouge">addCookie(HttpCookie cookie)</code> - adds a cookie</li>
  <li><code class="highlighter-rouge">id(K id)</code> - sets the entity key for the resource</li>
  <li><code class="highlighter-rouge">ids(Collection&lt;K&gt; ids)</code> - sets a list of entity keys</li>
  <li><code class="highlighter-rouge">name(String name)</code> - sets the name for a named resource method</li>
  <li><code class="highlighter-rouge">setParam(String name, Object value)</code> - sets a query param named
<code class="highlighter-rouge">name</code> to <code class="highlighter-rouge">value</code></li>
  <li><code class="highlighter-rouge">addParam(String name, Object value)</code> - adds <code class="highlighter-rouge">value</code> to the query
param named <code class="highlighter-rouge">name</code></li>
  <li><code class="highlighter-rouge">assocKey(String key, Object value)</code> - sets an association key
parameter</li>
  <li><code class="highlighter-rouge">pathKey(String key, Object value)</code> - sets a path key parameter
(entity key of a parent resource)</li>
  <li><code class="highlighter-rouge">paginate(int start, int count)</code> - sets pagination parameters</li>
  <li><code class="highlighter-rouge">fields(PathSpec... fieldPaths)</code> - sets the fields projection mask</li>
  <li><code class="highlighter-rouge">input(V entity)</code> - sets the input payload for the request</li>
  <li><code class="highlighter-rouge">inputs(Map&lt;K, V&gt; entities)</code> - sets the input payloads for batch
requests</li>
</ul>

<p>The following table summarizes the methods supported by each
RequestBuilder type.</p>

<p>|<em>. Request Builder |</em>. header |<em>. id |</em>. ids |<em>. name |</em>.
setParam |<em>. addParam |</em>. assocKey |<em>. pathKey |</em>. paginate |<em>.
fields |</em>. input |_. inputs |\
| Action | - | - | | - | - | - | | - | | | | |\
| Find | - | | | - | - | - | - | - | - | - | | |\
| Get | - | <del>* | | |</del> | - | | - | | - | | |\
| Create | - | | | | - | - | | - | | | - | |\
| Delete | - | <del>* | | |</del> | - | | - | | | | |\
| PartialUpdate | - | - | | | - | - | | - | | | - | |\
| Update | - | <del>* | | |</del> | - | | - | | | - | |\
| BatchGet | - | | - | | - | - | | - | | - | | |\
| BatchCreate | - | | | | - | - | | - | | | | - |\
| BatchDelete | - | | - | | - | - | | - | | | | |\
| BatchPartialUpdate | - | | | | - | - | | - | | | | - |\
| BatchUpdate | - | | | | - | - | | - | | | | - |\
*:It is not supported, if the method is defined on a simple resource.</p>

<p>Refer to the JavaDocs for specific details of RequestBuilder and Request
interfaces.</p>

<p><a id="RestspecIDL"></a></p>

<p><a id="wiki-IDL"></a></p>

<h2 id="restspec-idl">Restspec IDL</h2>

<p>Rest.li uses a custom format called REST Specification (Restspec) as its
interface description language (IDL). The Restspec provides a succinct
description of the URI paths, HTTP methods, query parameters, and JSON
format. Together, these form the interface contract between the server
and the client.</p>

<p>Restspec files are JSON format and use the file suffix *.restspec.json.</p>

<p>At a high level, the restspec contains the following information:</p>

<ul>
  <li>name of the resource</li>
  <li>path to the resource</li>
  <li>schema type (value type) of the resource</li>
  <li>resource pattern (collection / simple / association / actionsSet)</li>
  <li>name and type of the resource key(s)</li>
  <li>list of supported CRUD methods (CREATE, GET, UPDATE,
PARTIAL_UPDATE, DELETE, and corresponding batch methods)</li>
  <li>description of each FINDER, including
    <ul>
      <li>name</li>
      <li>parameter names, types, and optionality</li>
      <li>response metadata type (if applicable)</li>
    </ul>
  </li>
  <li>description of each ACTION, including
    <ul>
      <li>name</li>
      <li>parameter names, types, and optionality</li>
      <li>response type</li>
      <li>exception types</li>
    </ul>
  </li>
  <li>a description of each subresource, containing the information
described above</li>
</ul>

<p>Additional details on the Restspec format may be found in the <a href="https://github.com/linkedin/rest.li/wiki/Rest.li-.restspec.json-Format">design
documents</a>.
The Restspec format is formally described by the .pdsc schema files in
“com.linkedin.restli.restspec.* “ distributed in the restli-common
module.</p>

<p><a id="IDLGeneratorTool"></a></p>

<h3 id="idl-generator-tool">IDL Generator Tool</h3>

<p>The IDL generator is used to create the language-independent interface
description (IDL) from Rest.li resource implementations (annotated Java
code).</p>

<p>The IDL generator is available as part of the restli-tools JAR, as the
<code class="highlighter-rouge">com.linkedin.restli.tools.idlgen.RestLiResourceModelExporterCmdLineApp</code>
class.</p>

<p>For details on how to use the IDL Generator, see <a href="https://github.com/linkedin/rest.li/wiki/Gradle-build-integration">Gradle build
integration</a>.</p>

<p><a id="Client"></a>\
<a id="RestClient"></a></p>

<p><a id="wiki-RestClient"></a></p>

<h2 id="restclient">RestClient</h2>

<p><code class="highlighter-rouge">RestClient</code> encapsulates the communication with the remote resource.
<code class="highlighter-rouge">RestClient</code> accepts a <code class="highlighter-rouge">Request</code> object as input and provides a
<code class="highlighter-rouge">Response</code> object as output. The <code class="highlighter-rouge">Request</code> objects should usually be
built using the <a href="./Rest.li-User-Guide#type-safe-builders">generated type-safe client
builders</a>. Since the
<code class="highlighter-rouge">RestClient</code> interface is fundamentally asynchronous, the <code class="highlighter-rouge">Response</code>
must be obtained through either a <code class="highlighter-rouge">ResponseFuture</code> or a <code class="highlighter-rouge">Callback</code> (both
options are supported).</p>

<p><code class="highlighter-rouge">RestClient</code> is a simple wrapper around an R2 transport client. For
standalone / test use cases, the transport client can be obtained
directly from R2, for example, using the <code class="highlighter-rouge">HttpClientFactory</code>. If you
wish to use D2, the <code class="highlighter-rouge">Client</code> used by the <code class="highlighter-rouge">RestClient</code> must be a D2
client.</p>

<p>The <code class="highlighter-rouge">RestClient</code> constructor also requires a URI prefix that is
prepended to the URIs generated by the Request Builders. When using D2,
a prefix of <code class="highlighter-rouge">"d2://"</code> should be provided that results in URIs using the
D2 scheme.</p>

<h3 id="responsefuture">ResponseFuture</h3>

<p>The <code class="highlighter-rouge">RestClient</code> future-based interface returns <code class="highlighter-rouge">ResponseFuture</code>, which
implements the standard <code class="highlighter-rouge">Future</code> interface and extends it with a
<code class="highlighter-rouge">getResponse()</code> method. The advantage of <code class="highlighter-rouge">getResponse()</code> is that it is
aware of Rest.li exception semantics, throwing
<code class="highlighter-rouge">RemoteInvocationException</code> instead of <code class="highlighter-rouge">ExecutionException</code>.</p>

<h3 id="making-requests-using-the-restclient-and-generated-requestbuilders">Making requests using the RestClient and generated RequestBuilders</h3>

<p>The standard pattern for making requests using the RestClient is as
follows:</p>

<ol>
  <li>Build the request using the generated request builders</li>
  <li>Use the <code class="highlighter-rouge">RestClient#sendRequest</code> method to send the request and get
back a <code class="highlighter-rouge">ResponseFuture</code></li>
  <li>Call <code class="highlighter-rouge">ResponseFuture#getResponse</code> to get the <code class="highlighter-rouge">Response</code> that the
server returned. <strong>Note that this call blocks until the server
responds or there is an error!</strong></li>
</ol>

<p>Here is a more concrete example, where a client is making a GET request
to the /greetings resource -</p>

<p>```java\
// First we build the Request. builders is either a GreetingsBuilder or
GreetingsRequestBuilder\
Request<Greeting> getRequest = builders.get().id(id).build();</Greeting></p>

<p>// Send the Request and get back a ResponseFuture representing the
response. This call is non-blocking.\
ResponseFuture<Greeting> responseFuture =
restClient.sendRequest(getRequest);</Greeting></p>

<p>// Like the standard Java Future semantics, calling getResponse() here
IS blocking!\
Response<Greeting> getResponse = responseFuture.getResponse();</Greeting></p>

<p>// Get the entity from the Response\
Greeting responseGreeting = getResponse.getEntity();\
```</p>

<p>Look at the <code class="highlighter-rouge">com.linkedin.restli.client.Response</code> interface to see what
other methods are available for use.</p>

<h3 id="request-api-changes-in-restli--1244">Request API changes in Rest.li &gt;= 1.24.4</h3>

<p>There are two major changes:</p>

<ul>
  <li><code class="highlighter-rouge">CreateIdRequestBuilder</code>, which is the super class for all CREATE
request builders, now returns a <code class="highlighter-rouge">CreateIdRequest&lt;K, V&gt;</code> when the
<code class="highlighter-rouge">build()</code> method is called.</li>
  <li><code class="highlighter-rouge">BatchCreateIdRequestBuilder</code>, which is the super class for all
BATCH_CREATE request builders, now returns a
<code class="highlighter-rouge">BatchCreateIdRequest&lt;K, V&gt;</code> when the <code class="highlighter-rouge">build()</code> method is called.</li>
</ul>

<h3 id="response-api-changes-in-restli--1244">Response API Changes in Rest.li &gt;= 1.24.4</h3>

<p>Starting with Rest.li 1.24.4, we have introduced a few changes to the
<code class="highlighter-rouge">Response</code> API.</p>

<h4 id="response-from-a-create-and-batch_create-request">Response from a CREATE and BATCH_CREATE Request</h4>

<p>As mentioned in the section above, calling <code class="highlighter-rouge">build()</code> on a
<code class="highlighter-rouge">CreateIdRequestBuilder</code> gives us a <code class="highlighter-rouge">CreateIdRequest&lt;K, V&gt;</code>.\
When this is sent using a <code class="highlighter-rouge">RestClient</code> we get back (after calling
<code class="highlighter-rouge">sendRequest(...).getResponse().getEntity()</code>) an <code class="highlighter-rouge">IdResponse&lt;K&gt;</code> that
gives us a single, strongly-typed key.</p>

<p>Similarly, when a <code class="highlighter-rouge">RestClient</code> is used to send out a
<code class="highlighter-rouge">BatchCreateIdRequest&lt;K, V&gt;</code> we get back a <code class="highlighter-rouge">BatchCreateIdResponse&lt;K&gt;</code>,
which contains a <code class="highlighter-rouge">List</code> of strongly-typed keys.</p>

<h4 id="response-from-a-batch_get-request">Response from a BATCH_GET Request</h4>

<p>When a <code class="highlighter-rouge">BatchGetEntityRequest</code> is sent using a <code class="highlighter-rouge">RestClient</code> we get back
(after calling <code class="highlighter-rouge">sendRequest(...).getResponse().getEntity()</code>) a
<code class="highlighter-rouge">BatchKVResponse&lt;K,EntityResponse&lt;V&gt;&gt;</code> where <code class="highlighter-rouge">K</code> is the key type and <code class="highlighter-rouge">V</code>
is the value (which extends <code class="highlighter-rouge">RecordTemplate</code>) for the resource we are
calling.</p>

<p><code class="highlighter-rouge">EntityResponse</code> is a <code class="highlighter-rouge">RecordTemplate</code> with three fields:</p>

<ul>
  <li><code class="highlighter-rouge">entity</code> provides an entity record if the server resource finds a
corresponding value for the key;</li>
  <li><code class="highlighter-rouge">status</code> provides an optional status code;</li>
  <li><code class="highlighter-rouge">error</code> provides the error details from the server resource
(generally <code class="highlighter-rouge">entity</code> and <code class="highlighter-rouge">error</code> are mutually exclusive as <code class="highlighter-rouge">null</code>,
but it is ultimately up to the server resource).</li>
</ul>

<p>Note that since <code class="highlighter-rouge">EntityResponse</code> contains an <code class="highlighter-rouge">error</code> field, the
<code class="highlighter-rouge">Map&lt;K, V&gt;</code> returned by <code class="highlighter-rouge">BatchEntityResponse#getResults()</code> contains both
successful as well as failed entries. <code class="highlighter-rouge">BatchEntityResponse#getErrors()</code>
will only return failed entries.</p>

<h4 id="response-from-a-batch_update-batch_partial_update-and-batch_delete-request">Response from a BATCH_UPDATE, BATCH_PARTIAL_UPDATE, and BATCH_DELETE Request</h4>

<p>The response type of the <code class="highlighter-rouge">BatchUpdate</code> series methods are not changed.
However, similar to <code class="highlighter-rouge">EntityResponse</code>, we added a new <code class="highlighter-rouge">error</code> field to
<code class="highlighter-rouge">UpdateStatus</code> (the value type of the <code class="highlighter-rouge">BatchUpdate</code> series methods).
Furthermore, <code class="highlighter-rouge">BatchKVResponse&lt;K, UpdateStatus&gt;#getResults()</code> will
returns both successful as well as failed entries. <code class="highlighter-rouge">getErrors()</code> will
only return failed entries.</p>

<h3 id="error-semantics">Error Semantics</h3>

<p>The following diagram illustrates the request/response flow for a
client/server interaction. The call may fail at any point during this
flow, as described below.</p>

<p><img src="https://github.com/linkedin/rest.li/wiki/RequestFlow.png" alt="Rest.li Request Flow" title="Rest.li Request Flow" /></p>

<p>The following list describes the failures scenarios as observed by a
client calling <code class="highlighter-rouge">ResponseFuture.getResponse()</code></p>

<p>Failure Scenarios</p>

<ul>
  <li>Client Framework (outbound)
    <ul>
      <li><code class="highlighter-rouge">ServiceUnavailableException</code> - if D2 cannot locate a node for
the requested service URI</li>
      <li><code class="highlighter-rouge">RemoteInvocationException</code> - if R2 cannot connect to the remote
endpoint or send the request</li>
    </ul>
  </li>
  <li>Network Transport (outbound)
    <ul>
      <li><code class="highlighter-rouge">TimeoutException</code> - if a network failure prevents the request
from reaching the server</li>
    </ul>
  </li>
  <li>Server Framework (inbound)
    <ul>
      <li><code class="highlighter-rouge">RestLiResponseException</code> - if an error occurs within the
framework, resulting in a non-200 response</li>
      <li><code class="highlighter-rouge">TimeoutException</code> - if an error prevents the server from
sending a response</li>
    </ul>
  </li>
  <li>Server Application
    <ul>
      <li><code class="highlighter-rouge">RestLiResponseException</code> - if the application throws an
exception the server framework will convert it into a non-200
response</li>
      <li><code class="highlighter-rouge">TimeoutException</code> - if an application error prevents the server
from sending a response in a timely manner</li>
    </ul>
  </li>
  <li>Server Framework (outbound)
    <ul>
      <li><code class="highlighter-rouge">RestLiResponseException</code> - if an error occurs within the
framework, resulting in a non-200 response</li>
      <li><code class="highlighter-rouge">TimeoutException</code> - if an error prevents the server from
sending a response</li>
    </ul>
  </li>
  <li>Network Transport (inbound)
    <ul>
      <li><code class="highlighter-rouge">TimeoutException</code> - if a network failure prevents the response
from reaching the client</li>
    </ul>
  </li>
  <li>Client Framework (inbound)
    <ul>
      <li><code class="highlighter-rouge">RestLiDecodingException</code> - if the client framework cannot
decode the response document</li>
      <li><code class="highlighter-rouge">RemoteInvocationException</code> - if an error occurs within the
client framework while processing the response.</li>
    </ul>
  </li>
</ul>

<p><a id="wiki-ParSeq"></a></p>

<h2 id="request-options">Request Options</h2>

<p>Each request sent to a Rest.li server can be configured with custom
options by using an instance of <code class="highlighter-rouge">RestliRequestOptions</code>.
<code class="highlighter-rouge">RestliRequestOptionsBuilder</code> is required to construct an instance of
<code class="highlighter-rouge">RestliRequestOptions</code>. Once constructed, an instance of
<code class="highlighter-rouge">RestliRequestOptions</code> can then be passed to Rest.li generated type-safe
request builders. Subsequently, <code class="highlighter-rouge">RestClient</code> will construct a
<code class="highlighter-rouge">RestRequest</code> based on these custom options to send to the Rest.li
server. Currently we support specifying the following custom options per
Request:</p>

<h3 id="protocolversionoption">ProtocolVersionOption</h3>

<p>When sending a Request, the caller can specify what protocol version
option is to be used. The available ProtocolVersionOption(s) are:</p>

<h4 id="force_use_next">FORCE_USE_NEXT</h4>

<p>Use the next version of the Rest.li protocol to encode requests,
regardless of the version running on the server. The next version of the
Rest.li protocol is the version currently under development. This option
should typically NOT be used for production services.\
<strong>CAUTION</strong>: this can cause requests to fail if the server does not
understand the next version of the protocol.\
“Next version” is defined as
<code class="highlighter-rouge">com.linkedin.restli.internal.common.AllProtocolVersions.NEXT_PROTOCOL_VERSION</code>.</p>

<h4 id="force_use_latest">FORCE_USE_LATEST</h4>

<p>Use the latest version of the Rest.li protocol to encode requests,
regardless of the version running on the server.\
<strong>CAUTION</strong>: this can cause requests to fail if the server does not
understand the latest\
version of the protocol. “Latest version” is defined as
<code class="highlighter-rouge">com.linkedin.restli.internal.common.AllProtocolVersions.LATEST_PROTOCOL_VERSION</code>.</p>

<h4 id="use_latest_if_available">USE_LATEST_IF_AVAILABLE</h4>

<p>Use the latest version of the Rest.li protocol if the server supports
it. If the server version is less than the baseline Rest.li protocol
version then fail the request. If the server version is greater than the
next Rest.li protocol version then fail the request. If the server is
between the baseline and the latest version then use the server version
to encode the request. If the server version is greater than or equal to
the latest protocol version then use that to encode the request.</p>

<ul>
  <li>“Baseline version” is defined as
<code class="highlighter-rouge">com.linkedin.restli.internal.common.AllProtocolVersions.BASELINE_PROTOCOL_VERSION</code>.</li>
  <li>“Latest version” is defined as
<code class="highlighter-rouge">com.linkedin.restli.internal.common.AllProtocolVersions.LATEST_PROTOCOL_VERSION</code>.</li>
  <li>“Next version” is defined as
<code class="highlighter-rouge">com.linkedin.restli.internal.common.AllProtocolVersions.NEXT_PROTOCOL_VERSION</code>.</li>
</ul>

<p><strong>CAUTION</strong>: Please be very careful setting the non-default
<strong>FORCE_USE_NEXT</strong> or <strong>FORCE_USE_LATEST</strong> options as the protocol
version option in <code class="highlighter-rouge">RestLiRequestOptions</code>, since they may cause requests
to fail if the server does not understand the desired protocol request.
This form of configuration is normally used in migration cases.</p>

<h3 id="compressionoption">CompressionOption</h3>

<p>When sending a Request, the caller can force compression on or off for
each request.</p>

<h4 id="force_on">FORCE_ON</h4>

<p>Compress the request.</p>

<h4 id="force_off">FORCE_OFF</h4>

<p>Do not compress the request.</p>

<p>If <code class="highlighter-rouge">null</code> is specified, Rest.li <code class="highlighter-rouge">ClientCompressionFilter</code> will determine
whether we need to do client side compression based on request entity
length.</p>

<h3 id="contenttype">ContentType</h3>

<p>When sending a Request, the caller can also specify what content type is
to be used. The specified value will be set to the HTTP header
“Content-Type” for the request.</p>

<h4 id="json">JSON</h4>

<p>This will set “Content-Type” header value as “application/json”.</p>

<h4 id="pson">PSON</h4>

<p>This will set “Content-Type” header value as “application/x-pson”</p>

<p><strong>NOTE</strong>: Besides <code class="highlighter-rouge">RestliRequestOption</code>, the caller can also specify the
<code class="highlighter-rouge">ContentType</code> through the <code class="highlighter-rouge">RestClient</code> constructor by passing the
contentType parameter (as shown below), which will apply to all requests
sent through that client instance.</p>

<p>```java\
public RestClient(Client client, String uriPrefix, ContentType
contentType, List<AcceptType> acceptTypes)\
\`\`\`</AcceptType></p>

<p>However, this form of configuration has been DEPRECATED. Please use
<code class="highlighter-rouge">RestliRequestOptions</code> instead to set such custom options. In cases
where the caller has configured content type from multiple places,
RestClient will resolve request content type based on the following
precedence order:</p>

<ol>
  <li>Request header.</li>
  <li>RestliRequestOptions.</li>
  <li>RestClient configuration.</li>
</ol>

<p>If <code class="highlighter-rouge">null</code> is specified for content type from these 3 sources,
<code class="highlighter-rouge">RestClient</code> will use JSON as default.</p>

<h3 id="accepttype">AcceptType</h3>

<p>When sending a Request, the caller can also specify what media types it
can accept. The specified value will be set to the HTTP header “Accept”
for the request. If more than one AcceptType is specified, we will
generate an Accept header by appending each media type by a “q”
parameter for indicating a relative quality factor. For example:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;Accept: application/*; q=0.2, application/json&lt;/code&gt;
</code></pre></div></div>

<p>\
Quality factors allow the user or user agent to indicate the relative
degree of preference for that media type, using the scale from 0 to 1.
The default value is q=1. In our case, the quality factor generated is
based on the order of each accept type we specified in the list. See
http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html for details.</p>

<h4 id="json-1">JSON</h4>

<p>This will accept media type of “application/json”.</p>

<h4 id="pson-1">PSON</h4>

<p>This will accept media type of “application/x-pson”.</p>

<h4 id="any">ANY</h4>

<p>This will accept any media type.</p>

<p><strong>NOTE</strong>: Besides <code class="highlighter-rouge">RestliRequestOption</code>, the caller can also specify
AcceptType through the <code class="highlighter-rouge">RestClient</code> constructor by passing the
acceptTypes parameter (as shown below), which will apply to all requests
sent through that client instance.</p>

<p>```java\
public RestClient(Client client, String uriPrefix, List<AcceptType>
acceptTypes)\
public RestClient(Client client, String uriPrefix, ContentType
contentType, List<AcceptType> acceptTypes)\
\`\`\`\
However, this form of configuration has been DEPRECATED. Please use
`RestliRequestOptions` instead to set such custom options. In cases
where the caller has configured accept types from multiple places,
RestClient will resolve request accept type based on the following
precedence order:</AcceptType></AcceptType></p>

<ol>
  <li>Request header.</li>
  <li>RestliRequestOptions.</li>
  <li>RestClient configuration.</li>
</ol>

<p>If <code class="highlighter-rouge">null</code> is specified for the accept type from these 3 sources,
<code class="highlighter-rouge">RestClient</code> will not set the HTTP “Accept” header. If no accept header
field is present, then it is assumed by the Rest.li server that the
client accepts all media types based on the HTTP Spec (RFC 2616).</p>

<p>If <code class="highlighter-rouge">RestliRequestOptions</code> is not set, or is set to null, the request
builders will use
<code class="highlighter-rouge">RestliRequestOptions.DEFAULT_OPTIONS(ProtocolVersionOption.USE_LATEST_IF_AVAILABLE, null /*compression*/, null /*content type*/, null /*accept type*/)</code>
to generate the Request.</p>

<h2 id="parseq-integrated-rest-client">ParSeq Integrated Rest Client</h2>

<p>The <code class="highlighter-rouge">ParSeqRestClient</code> wrapper facilitates usage with ParSeq by
providing methods that return a <code class="highlighter-rouge">Promise</code> or a <code class="highlighter-rouge">Task</code>. For example,
users can create multiple requests and use ParSeq to send them in
parallel. This feature is independent of the asynchronous resources; in
particular, the server resource does not have to be asynchronous.</p>

<p>```java\
ParSeqRestClient client = new ParSeqRestClient(plain rest client);\
// send some requests in parallel\
Task&lt;Response&lt;?&gt;&gt; task1 = client.createTask(request1);\
Task&lt;Response&lt;?&gt;&gt; task2 = client.createTask(request2);\
Task&lt;Response&lt;?&gt;&gt; combineResults = …;\
// after we get our parallel requests, combine them\
engine.run(Tasks.seq(Tasks.par(task1, task2), combineResults))\
```\
Users of <code class="highlighter-rouge">createTask</code> are required to instantiate their own ParSeq
engine and start the task themselves.</p>

<p><a id="ClientCodeGeneratorTool"></a></p>

<p><a id="wiki-CodeGenTool"></a></p>

<h2 id="client-code-generator-tool">Client Code Generator Tool</h2>

<p>As described above, the Rest.li client framework includes a
code-generation tool that creates type-safe Request Builder classes
based on resource IDL files.</p>

<p>The code generator is available as part of the restli-tools JAR, as
<code class="highlighter-rouge">com.linkedin.restli.tools.clientgen.RestRequestBuilderGenerator</code>. The
generator is invoked by providing an output directory and a list of
input IDL files as command-line arguments.</p>

<p>In addition, the generator recognizes the following system properties:</p>

<ul>
  <li><code class="highlighter-rouge">generator.rest.generate.datatemplates</code> - boolean property
indicating whether the generator should generate Java RecordTemplate
classes for the .pdsc schemas referenced by the IDL file.</li>
  <li><code class="highlighter-rouge">generator.default.package</code> - the default package name for generated
classes</li>
  <li><code class="highlighter-rouge">generator.resolver.path</code> - a colon-separated list of filesystem
paths to search when resolving references to named schemas. See
“Data Template Generator” for more details.</li>
</ul>

<p>The Rest.li client code generator is integrated as part of the <code class="highlighter-rouge">pegasus</code>
gradle plugin. For details, see <a href="https://github.com/linkedin/rest.li/wiki/Gradle-build-integration">Gradle build
integration</a>.</p>

<p><a id="wiki-Extras"></a></p>

<h2 id="restli-extras">Rest.li-extras</h2>

<p>Rest.li can be used with the D2 layer for dynamic discovery and
client-side load balancing. The use of D2 is normally transparent at the
Rest.li layer. However, for applications wishing to make more
sophisticated use of Rest.li and D2, the <code class="highlighter-rouge">restli-extras</code> module is
provided.</p>

<h3 id="scatter--gather">Scatter / Gather</h3>

<p>The main feature supported in <code class="highlighter-rouge">restli-extras</code> is the ability to make
parallel “scatter/gather” requests across all the nodes in a cluster.
Currently, scatter/gather functionality is only supported for BATCH_GET
methods.</p>

<p>Scatter/gather makes use of D2’s support for consistent hashing, to
ensure that a given key is routed to the same server node when possible.
The <code class="highlighter-rouge">ScatterGatherBuilder</code> interface can be used to partition a single
large <code class="highlighter-rouge">BatchGetRequest</code> into <code class="highlighter-rouge">N</code> <code class="highlighter-rouge">BatchGetRequests</code>, one for each node
in the cluster. The key partitioning is done according to the D2
consistent hashing policy, using a <code class="highlighter-rouge">KeyMapper</code> object obtained from the
D2 <code class="highlighter-rouge">Facilities</code> interface. Batch updates and deletes are also supported.</p>

                     </div>
                   </div>
</div>



      <footer class="page-footer">
    <div class="container">
      <div class="row">
        <div class="col s6">
          <h5>Rest.li</h5>
          <p class="text-lighten-4">Rest.li is an open source REST framework for building robust, scalable RESTful architectures using type-safe bindings and asynchronous, non-blocking IO. Rest.li fills a niche for applying RESTful principles at scale with an end-to-end developer workflow for building REST APIs, which promotes clean REST practices, uniform interface design and consistent data modeling.</p>
        </div>
        <div class="col s5 offset-s1">
          <h5 class="black-text">Community</h5>
          <ul>
              <li>Github <a class="" href="https://github.com/linkedin/rest.li">Rest.li</a></li>
              <li>Linkedin <a class="" href="http://www.linkedin.com/groups/Restli-4855943">Rest.li Group</a></li>
            <li>Follow us on twitter: <a class="" href="https://twitter.com/rest_li"> @rest_li</a></li>
            <li>Issue Tracking: <a class="" href="https://github.com/linkedin/rest.li/issues">github issue tracking</a></li>
          </ul>
        </div>
      </div>
    </div>
    <div class="footer-copyright">
        <div class="container">
            <div>
                <span style="text-align: right; float: left">
                Copyright © 2018. Powered by <a target="_blank" href="http://jekyllrb.com/" class="black-text text-lighten-3">Jekyll</a>
                </span> 
            </div>
        </div>  
    </div>
</footer>
      
    <!--  Scripts-->                                                                               
<script src="/js/jquery.min.js"></script>
<script src="/js/materialize.min.js"></script>
<script src="/js/init.js"></script>

  </body>

</html>
