<!DOCTYPE html>
<html lang="en">

  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0"/>

    <title>Gradle build integration</title>
    <meta name="description" content="A REST framework for building scalable service architectures using dynamic discovery and simple asynchronous APIs" />

  
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" type="text/css" media="screen,projection" href="/assets/materialize.css" />
    <link rel="stylesheet" type="text/css" media="screen,projection" href="/assets/main.css">
    <link rel="canonical" href="http://localhost:4000/setup/gradle" />
    <link rel="alternate" type="application/rss+xml" title="rest.li" href="/feed.xml" />
  
    
</head>


  <body>

    <nav class="dark-grey" role="navigation">
    <div class="nav-wrapper container"><a id="logo-container" class="brand-logo" href="/">Rest.li</a>


          <ul class="right hide-on-med-and-down">
               
      
        <li>
          <a href="/rest.li/get_started/quick_start" >
            Getting Started
          </a>
        </li>
        
        <li>
          <a href="/rest.li/user_guide/server_architecture" >
            User guide
          </a>
        </li>
        
        <li>
          <a href="/rest.li/reference/architecture" >
            API reference
          </a>
        </li>
        
        <li>
          <a href="/rest.li/contribute/howto" >
            Contribute
          </a>
        </li>
        
          </ul>


      <a href="#" data-activates="nav-mobile" class="button-collapse"><i class="material-icons">menu</i></a>
    </div>
</nav>


        <div class="container">
        <div class="row">
                <div class="col s12 m4 l3"> 
               
                    
                   
                    
                     <ul class="nav_items">
                        <li><span class="nav_sub-title">Getting Started</span></li>
                        <ul>
                       
                         <li><a href="/rest.li/get_started/quick_start">Quick-start guide</a></li>
                       
                         <li><a href="/rest.li/start/d2_quick_start">Dynamic discovery</a></li>
                       
                         <li><a href="/rest.li/start/unstructured">Unstructured Data (BLOB)</a></li>
                       
                        </ul>
                     </ul>
                        
                   
                    
                     <ul class="nav_items">
                        <li><span class="nav_sub-title">Installation</span></li>
                        <ul>
                       
                         <li><a href="/rest.li/setup/building">Building Rest.li from Source</a></li>
                       
                         <li><a href="/rest.li/setup/gradle">Gradle build integration</a></li>
                       
                        </ul>
                     </ul>
                        
                    </div>
                     <div class="markdown-body col s12 m3 l9">
                            <h1 id="gradle-build-integration">Gradle build integration</h1>
<ul>
  <li><a href="https://github.com/linkedin/rest.li/wiki/Gradle-build-integration#introduction">Introduction</a></li>
  <li><a href="https://github.com/linkedin/rest.li/wiki/Gradle-build-integration#an-example">An Example</a></li>
  <li><a href="https://github.com/linkedin/rest.li/wiki/Gradle-build-integration#compatibility">Compatibility</a></li>
  <li><a href="https://github.com/linkedin/rest.li/wiki/Gradle-build-integration#publishing-maven-artifacts">Publishing Maven Artifacts</a></li>
  <li><a href="https://github.com/linkedin/rest.li/wiki/Gradle-build-integration#pegasus-plugin-in-detail">Pegasus Plugin in Detail</a></li>
  <li><a href="https://github.com/linkedin/rest.li/wiki/Gradle-build-integration#underlying-java-classes-for-build-integration">Underlying Java Classes for Build Integration</a></li>
</ul>

<h1 id="introduction">Introduction</h1>
<p>Gradle integration is provided as part of Rest.li.  Pegasus simplifies use of Rest.li’s code generators and compatibility checking by fully integrating them into the build system. (Note ‘pegasus’ is also the code name for the Rest.li project).</p>

<p>The underlying Java classes that enable code generation and validation are part of the Rest.li source and could be used to integrate with other build tools.</p>

<p>Adding the plugin is simple. First add a buildscript dependency on the <code class="highlighter-rouge">com.linkedin.pegasus:pegasus-plugin</code> artifact and then use <code class="highlighter-rouge">apply plugin 'pegasus'</code> in your build.gradle files.  This topic is explained in detail below.</p>

<p><strong>Gradle 1.8+ is required.</strong></p>

<h1 id="an-example">An Example</h1>

<p>As an example,  let’s consider a simple Rest.li project with three modules:</p>

<ul>
  <li>An <code class="highlighter-rouge">/api</code> module containing pegasus schema definitions in the <code class="highlighter-rouge">src/main/pegasus</code> directory.  Also this is where java client bindings for the service will be generated (the client-bindings are sometimes not a separate project, but are put into the ‘/api’ project along with the .pdsc’s).</li>
  <li>A <code class="highlighter-rouge">/server</code> module containing resources defined in java classes in the <code class="highlighter-rouge">src/main/java</code> directory under the <code class="highlighter-rouge">com.linkedin.restli.example.impl</code> namespace  (E.g. com.linkedin.restli.example.impl.RestLiExampleBasicServer.java).</li>
  <li>An example java client that uses the client-bindings.</li>
</ul>

<h2 id="root-buildgradle">Root build.gradle</h2>

<p>/build.gradle:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apply plugin: 'idea'
apply plugin: 'eclipse'

project.ext.externalDependency = [
  'pegasusVersion' : '&lt;version&gt;'
]

buildscript {
  repositories {
    mavenLocal()
    mavenCentral()
  }
  dependencies {
    classpath group: 'com.linkedin.pegasus', name: 'gradle-plugins', version: '&lt;version&gt;'
  }
}

subprojects {
  apply plugin: 'maven'

  afterEvaluate {
    if (project.plugins.hasPlugin('java')) {
      sourceCompatibility = JavaVersion.VERSION_1_6
    }

    // add the standard pegasus dependencies wherever the plugin is used
    if (project.plugins.hasPlugin('pegasus')) {
      dependencies {
        dataTemplateCompile spec.product.pegasus.data
        restClientCompile spec.product.pegasus.restliClient

        // needed for Gradle 1.9+
        restClientCompile spec.product.pegasus.restliCommon
      }
    }
  }

  repositories {
    mavenLocal()
    mavenCentral()
  }
}
</code></pre></div></div>

<p>/settings.gradle:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>include 'api'
include 'server'
include 'client'
</code></pre></div></div>

<h2 id="buildgradle-for-data-api-project">build.gradle for Data API Project</h2>

<p>/api/build.gradle:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apply plugin: 'pegasus'
</code></pre></div></div>

<p>In <code class="highlighter-rouge">/api</code>,  Pegasus Data Schemas (.pdsc’s) should be added under <code class="highlighter-rouge">/src/main/pegasus</code>.  E.g. <code class="highlighter-rouge">/src/main/pegasus/com/linkedin/restli/example/Hello.pdsc</code>.</p>

<p>The pegasus plugin will detect the presence of .pdsc files and automatically use the <code class="highlighter-rouge">dataTemplateGenerator</code> task to generate java bindings for the .pdsc’s.  In this example,  a <code class="highlighter-rouge">Hello.java</code> class would be generated.</p>

<p>The <code class="highlighter-rouge">dataTemplateCompile</code> task automatically adds pegasus schemas that Hello.pdsc depends on,  in this case,  Hello.pdsc depends only on the core data libraries of pegasus,  but projects containing other .pdsc’s could be depended on.</p>

<p>Pegasus will detect when a project contains interface definitions (called idl and located in .restspec.json files) in it’s <code class="highlighter-rouge">/src/mainGeneratedRest/idl</code> directory (usually copied in from an idl extraction task from the server, see below) and will generate java bindings.   For example, <code class="highlighter-rouge">HelloBuilder.java</code> is generated from the idl of the hello resource (<code class="highlighter-rouge">/src/main/idl/com/linkedin/restli/example/impl/Hello.restspec.json) and it written to the </code>/src/mainGeneratedRest/java’ directory of the <code class="highlighter-rouge">/api</code> project.</p>

<h2 id="buildgradle-for-server-project">build.gradle for Server project</h2>

<p>/server/build.gradle:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apply plugin: 'java'
apply plugin: 'pegasus'

ext.apiProject = project(':api')
pegasus.main.idlOptions.addIdlItem(['com.linkedin.restli.example.impl']) // optional, if not set, all packages are scanned for resource classes

dependencies {
  compile project(path: ':api', configuration: 'dataTemplate')
  compile "com.linkedin.pegasus:restli-server:&lt;version&gt;"
  // ...
}
</code></pre></div></div>

<p>In <code class="highlighter-rouge">/server</code>, pegasus “Resource” java classes should be defined and should be in the package(s) referred to by <code class="highlighter-rouge">pegasus.main.idlOptions</code>.  E.g.  <code class="highlighter-rouge">/src/main/java/com/linkedin/restli/example/impl.HelloResource.java</code>.</p>

<p>Pegasus will extract an interface definition (.restspec.json) from the resource class and write it to <code class="highlighter-rouge">/src/mainGeneratedRest/idl</code> directory.</p>

<p>Once the idl has been generated, it will be copied to the project identified by <code class="highlighter-rouge">ext.apiProject</code>.  In this example, it will be copied to <code class="highlighter-rouge">/api/src/main/idl</code>.  Before it is copied, <code class="highlighter-rouge">api/src/main/idl</code> is scanned for pre-existing idl.  If any is found,  it is compared with the replacement idl that will be copied in and a compatibility checker is run that will return errors if the replacement idl is not backward compatible with the existing idl.  The compatibility checks can be disabled by setting (but be warned, compatibility errors mean that a server running the new interface definition is now incompatible with clients running older versions, and should not be pushed to production systems).  If the compatibility checks pass, the idl is copied into the client directories.  Once copied, new ‘Client Bindings’ may be generated for the client, see below.</p>

<p>The compile dependency on <code class="highlighter-rouge">:api</code> is required if the HelloResource.java depends on Hello.pdsc and it’s generated binding Hello.java.   Note that the dependency includes a ‘configuration’ identifying this as a ‘dataTemplate’ dependency.</p>

<h2 id="buildgradle-for-example-java-client">build.gradle for Example Java Client</h2>

<p>/client/build.gradle:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apply plugin: 'java'

dependencies {
  compile project(path: ':api', configuration: 'restClient')
}
</code></pre></div></div>

<p>Once rest client bindings in the api project have been generated,  it is trivial for a engineer to depend on the api project and use the generated client bindings to make calls to the new rest.li interface from any remote service.</p>

<p>One must add a compile dependency the ‘api’ project (or depend on it’s published artifacts, more about this below) and be sure to set the dependency configuration to ‘restClient’.  Once this is done, it’s easy to use the <code class="highlighter-rouge">HelloBuilder</code> class to construct a request.</p>

<h1 id="compatibility">Compatibility</h1>

<p>To manage compatibility checking use the rest.model.compatibility flag.   There are 4 different options:  ‘off’, ‘equivalent’, ‘backwards’ and ‘ignore’.</p>

<p>By default the compatibility strategy is ‘backwards’. ‘backwards’ will only fail on backwards incompatible changes and is the recommended setting to run during normal development.</p>

<p>If you are building rest.li services in a continuous integration environment, we suggest that you set builds to run on ‘equivalent’, meaning that ALL changes to an interface will cause a build failure. This will ensure that checked in code exactly corresponds with the interface.</p>

<p>If set to ‘off’ the compatibility check is skipped entirely.   ‘ignore’ will run the compatibility checker but will not fail for backward incompatible changes (and will print out the incompatibilities).</p>

<p>If you wish, you may set a local default compatibility level. To do so, modify or create a ~/.gradle/gradle.properties to include:</p>

<p><strong>~/.gradle/gradle.properties:</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Prest.model.compatibility=&lt;desired compatibility level here&gt;
</code></pre></div></div>

<p>For example, to run a build ignoring backward incompatable interface changes (WARNING: remember that backward incompatible changes could break your clients):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gradle build -Prest.model.compatibility=ignore
</code></pre></div></div>

<p>To acknowledge a backwards compatible interface change use:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gradle build -Prest.model.compatibility=backwards
</code></pre></div></div>

<p>For additional details on compatibility checking, see <a href="https://github.com/linkedin/rest.li/wiki/Snapshots-and-Resource-Compatibility-Checking">Resource Compatibility Checking</a>.</p>

<h1 id="publishing-maven-artifacts">Publishing Maven Artifacts</h1>

<p>Often, the client bindings need to be accessible to developers outside the project workspace where the service is developed.</p>

<p>To publish rest client bindings to any maven repo first modify the api project’s gradle to look like:</p>

<p>/api/build.gradle:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// ... /api/build.gradle code from above ...

artifacts {
  archives mainRestClientJar
  archives mainDataTemplateJar
} 

configure(install.repositories.mavenInstaller) {
  addFilter('rest-client') {artifact, file -&gt;
    artifact.name == 'api-rest-client'
  }.artifactId = 'rest-client'
  
  addFilter('data-template') {artifact, file -&gt;
    artifact.name == 'api-data-template'
  }.artifactId = 'data-template'
  // artifact names for 'data-model', 'avro-schema' and 'rest-model' may be added as well if needed
}
</code></pre></div></div>

<p>The ‘artifacts’ section tells gradle to build jar files for the rest client bindings and the data templates.</p>

<p>The configure part instructs gradle to publish both artifacts into maven.  Setting names for each (by default gradle names the artifact publish to maven to ‘api’ and since there are two artifacts, they need to be given distinct names).</p>

<p>Next, update the root build.gradle file to include project information withing the subprojects section:</p>

<p>/build.gradle</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// ... /build.gradle code from above ...

subprojects {
  // ...

  project.group = 'org.example'
  project.version = '0.1'
}
</code></pre></div></div>

<p>Once the api build.gradle is updated.  One can publish the maven artifacts.  To publish to the maven local repo, simply run:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gradle install
</code></pre></div></div>

<p>to publish to a remove maven repository follow the <a href="http://www.gradle.org/docs/current/userguide/artifact_management.html">gradle documentation</a></p>

<p>Once published, other projects may import the client bindings by depending on the two maven artifacts, e.g.:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dependencies {
  compile "org.example:rest-client:0.1"
  compile "org.example:data-template:0.1"
}
</code></pre></div></div>

<h1 id="pegasus-plugin-in-detail">Pegasus Plugin in Detail</h1>

<p>The gradle tasks for pegasus are provided by the ‘pegasus’ plugin.  The source for this plugin is in <code class="highlighter-rouge">PegasusGeneratorV2Plugin.groovy</code>.  This plugin defines custom of gradle <code class="highlighter-rouge">SourceDirectorySet</code>s for the ‘idl’, ‘pegasus’ source types and <code class="highlighter-rouge">tasks</code> for the rest.li code generators.  It also defines custom published artifact “configurations” and dependencies on between these custom published artifact “configurations”.</p>

<h2 id="source-directory-sets">Source Directory Sets</h2>

<p>The plugin recognizes a number of source directories in rest.li projects.  When any of these directories are detected (and they contain at least one source file), the plugin dynamically adds tasks the gradle build dependency tree for these directories.</p>

<p>In this section we below refers to gradle <code class="highlighter-rouge">sourceSets</code>.  The most common sourceSets are <code class="highlighter-rouge">main</code> and <code class="highlighter-rouge">test</code>.</p>

<h3 id="srcsourcesetpegasus"><code class="highlighter-rouge">src/{sourceSet}/pegasus</code></h3>

<p>Used by ‘api’ modules.</p>

<p>Contains data schemas (.pdsc) files.  If .pdsc files are present in this directory, the <code class="highlighter-rouge">generate{sourceSet}DataTemplate</code> tasks (e.g. <code class="highlighter-rouge">generateMainDataTemplate</code>) will generate java data templates (RecordTemplate java classes) in the <code class="highlighter-rouge">src/{sourceSet}GeneratedDataTemplate</code> directory.</p>

<p>The .pdsc files are published into a <code class="highlighter-rouge">*-data-template.jar</code> artifact.  If ivy is used this artifact is published with the module name and under the ‘data-template’ classification.</p>

<p>The generated java data templates (RecordTemplate java classes) are are published as a <code class="highlighter-rouge">-data-model.jar</code> artifact.   If ivy is used this artifact is published with the module name and under the ‘data-model’ classification.</p>

<h3 id="srcsourcesetgeneratedrestidl"><code class="highlighter-rouge">src/{sourceSet}GeneratedRest/idl</code></h3>

<p>Used by ‘server’ modules.</p>

<p>These files are generated by the <code class="highlighter-rouge">generateRestModel</code> task, for modules containing {*Resource.java} files (which must be in a package referenced by <code class="highlighter-rouge">pegasus.{sourceSet}.idlOptions.addIdlItem(namespaces)</code>).   One important aspect of idl is that by convention they are generated by a ‘server’ module (and written to the <code class="highlighter-rouge">src/{sourceSet}GeneratedRest/idl</code>) and then are copied to the <code class="highlighter-rouge">/src/{sourceSet}/idl</code> directory of an api module (via the <code class="highlighter-rouge">ext.apiProject</code> property).</p>

<p>No artifacts are published directly from the server for these files,  see <code class="highlighter-rouge">src/{sourceSet}/idl</code> for details on how they are published from the ‘api’ project.</p>

<h3 id="srcsourcesetidl"><code class="highlighter-rouge">src/{sourceSet}/idl</code></h3>

<p>Used by ‘api’ modules.</p>

<p>Contains published idl (.restspec.json) files.  These files represent the interface definition of the rest.li resources provided by some service.   They should be checked in to source control.   They are copied into the idl directory from server module by the <code class="highlighter-rouge">publishRestliIdl</code> task.  For this copy to happen the server module must contain a <code class="highlighter-rouge">ext.apiProject</code> property referencing this ‘api’ module.  As part of this copy, idl compatibility validation will be run (see above for details).</p>

<p>The idl is published as a <code class="highlighter-rouge">*-rest-model.jar</code> artifact.  If ivy is used this artifact is published with the module name and under the ‘rest-model’ classification.</p>

<h3 id="srcsourcesetgeneratedavroschemaavro"><code class="highlighter-rouge">src/{sourceSet}GeneratedAvroSchema/avro</code></h3>

<p>Used by ‘api’ modules.</p>

<p>Avro schema files (.avsc) generated from pegasus data schema files (.pdsc) by the <code class="highlighter-rouge">generateAvroSchema</code> task.</p>

<h2 id="generator-tasks">Generator Tasks</h2>

<p>All the following tasks are automatically added by the ‘pegasus’ gradle plugin into the gradle task dependency hierarchy.  They run automatically and in the correct order run as part of ‘gradle build’, ‘gradle jar’ and ‘gradle compileJava’ when the plugin detects that they are needed.</p>

<h3 id="generaterestmodel"><code class="highlighter-rouge">generateRestModel</code></h3>

<p>Generates .restspec.json files from java files annotated as rest.li resources in the namespaces that have been added to the idl list using <code class="highlighter-rouge">pegasus.{sourceSet}.idlOptions.addIdlItem()</code>.  Writes these .restspec.json files into the <code class="highlighter-rouge">src/{sourceSet}GeneratedRest/idl</code> directory.  This tasks is depended on by the publishRestliIdl task.</p>

<h3 id="publishrestliidl"><code class="highlighter-rouge">publishRestliIdl</code></h3>

<p>Copies idl (restspec.json) from server to api project (or whatever the ext.apiProject property is set to).  These files are normally located in the <code class="highlighter-rouge">src/mainGeneratedRest/idl</code> directory in the server project and the <code class="highlighter-rouge">src/main/idl</code> direcotry in the api project.  This tasks runs compatibility validation (see above).  While not strictly a ‘generate’ task, it is a essential part of the generator flow.  It is depended on by the jar task.</p>

<h3 id="publishrestlisnapshot"><code class="highlighter-rouge">publishRestliSnapshot</code></h3>

<p>Works the same as <code class="highlighter-rouge">publishRestliIdl</code> except that it copies “snapshot.json” files usually located in <code class="highlighter-rouge">src/mainGeneratedRest/snapshot</code> from the server project to the <code class="highlighter-rouge">src/main/snapshot</code> directory in the api project.</p>

<p>Snapshot files are used for compatibility checking whereas idl files are the formal interface definition and are used to generate client bindings.</p>

<h3 id="generatesourcesetgeneratedrestrestclient"><code class="highlighter-rouge">generate{sourceSet}GeneratedRestRestClient</code></h3>

<p>Generates java client bindings (<code class="highlighter-rouge">*Builders.java</code> classes) into the <code class="highlighter-rouge">src/{sourceSet}GeneratedRest/java</code>.  It depends on the .restspec.json  files in <code class="highlighter-rouge">src/{sourceSet}/idl</code> directory and the pegasus schemas (.pdsc files) in <code class="highlighter-rouge">src/{sourceSet}/pegasus</code> as well as from ‘dataModel’ dependencies (in ivy, these are dependencies from the “data-model” classification).   Depended on by the compileJava task.</p>

<h3 id="generatedatatemplate"><code class="highlighter-rouge">generateDataTemplate</code></h3>

<p>Generates java data template bindings (RecordTemplate java classes).  It depends on the pegasus schemas (.pdsc files) in <code class="highlighter-rouge">src/{sourceSet}/pegasus</code> as well as from ‘dataModel’ dependencies (in ivy, these are dependencies from the “data-model” classification).  Depended on by the compileJava task.</p>

<h3 id="generateavroschema"><code class="highlighter-rouge">generateAvroSchema</code></h3>

<p>Generates avro schemas (.avsc files) from the pegasus schemas (.pdsc files) in <code class="highlighter-rouge">src/{sourceSet}/pegasus</code>.  Requires the same ‘dataModel’ dependencies as required by the pegasus schemas (in ivy, these are dependencies from the “data-model” classification).  Depended on by generateDataTemplate task.</p>

<p>To run this task, the <code class="highlighter-rouge">avroSchemaGenerator</code> “configuration” must be configured with rest.li’s <code class="highlighter-rouge">data-avro-generator</code> artifact.  This is done by adding the follow dependency:</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">dependencies</span> <span class="o">{</span>
  <span class="n">avroSchemaGenerator</span> <span class="s2">"com.linkedin.pegasus:data-avro-generator:&lt;pegasus-version&gt;"</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="published-artifacts-and-their-classifications">Published artifacts and their classifications</h2>

<h3 id="-data-modeljar-artifact"><code class="highlighter-rouge">*-data-model.jar</code> artifact</h3>

<p>Contains .pdsc files, generated by the <code class="highlighter-rouge">generateDataModel</code> task.   This is only generated from a project if it contains one or more .pdsc files in it’s <code class="highlighter-rouge">src/{sourceSet}/pegasus</code> directory.</p>

<ul>
  <li>Ivy coordinates: use module’s group, name and version, use ‘data-model’ as classification</li>
  <li>Maven coordinates: use module’s group and version.  Use whatever name was configured for the mavenInstaller, which by convention should be ‘{modulename}-data-model’ (see above section about publish maven artifacts).</li>
</ul>

<p>###<code class="highlighter-rouge">*-data-template.jar</code> artifact</p>

<p>Contains java generated bindings (.class files) for accessing the pegasus schemas (.pdsc files) in the module’s <code class="highlighter-rouge">src/{sourceSet}/pegasus</code> directory.  This artifact is generated by the <code class="highlighter-rouge">generateDataTemplate</code> task.  This artifact is only generated from a project if it contains one or more .pdsc files in it’s <code class="highlighter-rouge">src/{sourceSet}/pegasus</code> directory.</p>

<p>This artifact will also define dependencies in it’s .pom or .ivy file to data-template artifacts it depends on (these are specified as <code class="highlighter-rouge">dataTemplate</code> dependencies in the module’s build.gradle).</p>

<ul>
  <li>Ivy coordinates: use module’s group, name and version, use ‘data-template’ as classification</li>
  <li>Maven coordinates: use module’s group and version.  Use whatever name was configured for the mavenInstaller, which by convention should be ‘{modulename}-data-template’ (see above section about publish maven artifacts).</li>
</ul>

<h3 id="-avro-schemajar-artifact"><code class="highlighter-rouge">*-avro-schema.jar</code> artifact</h3>

<p>Contains .avro schema files for the pegasus schemas (.pdsc files) in this module’s <code class="highlighter-rouge">src/{sourceSet}/pegasus</code> directory.  This .avro files are generated by the <code class="highlighter-rouge">generateAvroSchema</code> task.</p>

<p>This artifact will also define dependencies in it’s .pom or .ivy file to avro-schemas artifacts it depends on (these are specified as <code class="highlighter-rouge">dataTemplate</code> dependencies in the module’s build.gradle).</p>

<ul>
  <li>Ivy coordinates: use module’s group, name and version, use ‘avro-schema’ as classification</li>
  <li>Maven coordinates: use module’s group and version.  Use whatever name was configured for the mavenInstaller, which by convention should be ‘{modulename}-avro-schema’ (see above section about publish maven artifacts).</li>
</ul>

<h3 id="-rest-modeljar-artifact"><code class="highlighter-rouge">*-rest-model.jar</code> artifact</h3>

<p>Contains .idl (restspec.json) files for the idl in the module’s `src/{sourceSet}/idl’ directory.  These .idl files are generated by the generateRestModel task from a server then copied to an api project by the publishRestliIdl task (via the ext.apiProject property).</p>

<ul>
  <li>Ivy coordinates: use module’s group, name and version, use ‘rest-model’ as classification</li>
  <li>Maven coordinates: use module’s group and version.  Use whatever name was configured for the mavenInstaller, which by convention should be ‘{modulename}-rest-model’ (see above section about publish maven artifacts).</li>
</ul>

<h3 id="-rest-clientjar"><code class="highlighter-rouge">*-rest-client.jar</code></h3>

<p>Contains rest client java bindings (*Builders.java classes) generated from the idl of the source module.</p>

<p>This artifact will also define dependencies in it’s .pom or .ivy file to java data template binding artifacts (<code class="highlighter-rouge">*-data-model.jar</code>) it requires, including the one for the module itself and for any other pegasus schemas it depends on (these are specified as <code class="highlighter-rouge">dataModel</code> dependencies in the module’s build.gradle).</p>

<ul>
  <li>Ivy coordinates: use module’s group, name and version, use ‘rest-client’ as classification</li>
  <li>Maven coordinates: use module’s group and version.  Use whatever name was configured for the mavenInstaller, which by convention should be ‘{modulename}-rest-client’ (see above section about publish maven artifacts).</li>
</ul>

<h2 id="dependency-types">Dependency types</h2>

<p>There are two types of pegasus plugin dependency types.  The first type is one required by the plugin for running code generators and compiling code.  The second type is those developers can use to define different sorts dependencies between the various source languages, primarily pegasus schemas (.pdsc files).</p>

<h3 id="dependencies-used-by-build-tooling">Dependencies used by build tooling</h3>

<p><code class="highlighter-rouge">restTools</code> - required by ‘api’ and ‘server’ modules to generate rest client bindings (*Builders.java files), run compatibility checks, and use rest.li document generation (docgen).   The dependency must refer to a compatible version of the pegasus:rest-tools artifact.</p>

<p><code class="highlighter-rouge">dataTemplateCompile</code> - Required by ‘api’ modules to do data template compilation.  The dependency must refer to a compatible version of the pegasus:data artifact.</p>

<p><code class="highlighter-rouge">dataTemplateGenerator</code> - Required by ‘api’ modules to do data template generation. The dependency must refer to a compatible version of the pegasus:generator artifact.</p>

<p><code class="highlighter-rouge">restClientCompile</code> - Required by ‘api’ modules to compile client java bindings (*Builders.java files) to .class files. The dependency must refer to a compatible version of the pegasus:restli-client artifact.</p>

<p>Example build.gradle for an ‘api’ module:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
dependencies {
  compile "com.linkedin.pegasus:restli-client:&lt;version&gt;"

  dataTemplateCompile "com.linkedin.pegasus:data:&lt;version&gt;"
  dataTemplateGenerator "com.linkedin.pegasus:generator:&lt;version&gt;"
  restTools "com.linkedin.pegasus:restli-tools:&lt;version&gt;"
  restClientCompile "com.linkedin.pegasus:restli-client:&lt;version&gt;"
}
</code></pre></div></div>

<h3 id="pegasus-schema-dependencies">Pegasus Schema Dependencies</h3>

<p><code class="highlighter-rouge">dataTemplate</code> - Adds a dependency on the pegasus schemas from another module or artifact.  This is required when the current module’s pdsc files refer to schema types that reside in another module or artifact.</p>

<p>Example build.gradle:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
dependencies {
  // for ivy:
  dataTemplate group: 'org.example', name: 'common-pegasus-schemas', version: '1.0', classifier: 'dataTemplate'
  // for maven, remove the classifier and change the name to match the artifact name of the published dataTemplate, by convention it should be '{modulename}-data-template}'
  ...
}
</code></pre></div></div>

<h1 id="underlying-java-classes-for-build-integration">Underlying Java Classes for Build Integration</h1>

<p>This is provided for reference only.  A understanding of these classes is not required to use pegasus.  These classes would be useful primarily if one were deeply integrating pegasus with a build system not already supported by pegasus.</p>

<h2 id="avro-schema-generator">Avro Schema Generator</h2>
<p>Generate Avro avsc files from Pegasus Data Model schemas (.pdsc files).</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java [-Dgenerator.resolver.path=&lt;dataSchemaRelativePath&gt;] \
  -cp &lt;CLASSPATH&gt; com.linkedin.data.avro.generator.AvroSchemaGenerator \
  &lt;outputDir&gt; [&lt;inputFileOrDir&gt; ...]
</code></pre></div></div>

<ul>
  <li>dataSchemaRelativePath - Path to .pdsc files. (e.g.  /src/main/pegasus).</li>
  <li>CLASSPATH - ‘com.linkedin.pegasus:data:[CURRENT_VERSION]’ AND ‘com.linkedin.pegasus:data-avro:[CURRENT_VERSION]’ artifacts and all their dependencies.</li>
  <li>outputDir - output directory for generated avsc files</li>
  <li>inputFileOrDir - file name of a Pegasus data schema file, a directory containing Pegasus data schema files, or a fully qualified schema name</li>
</ul>

<p>Build integration: for builds requiring avro schemas, assembly (creation of jar) should depend on this task</p>

<h2 id="pegasus-data-template-generator">Pegasus Data Template Generator</h2>
<p>Generates Java data templates (.java files) from Pegasus Data Model schemas (.pdsc files).</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java [-Dgenerator.resolver.path=&lt;dataSchemaRelativePath&gt;] -cp &lt;CLASSPATH&gt; \
  com.linkedin.pegasus.generator.PegasusDataTemplateGenerator \
  &lt;outputDir&gt; [&lt;inputFileOrDir&gt; ...]
</code></pre></div></div>

<ul>
  <li>dataSchemaRelativePath - Path to .pdsc files. (e.g.  /src/main/pegasus).</li>
  <li>CLASSPATH - ‘com.linkedin.pegasus:generator:[CURRENT_VERSION]’ artifact and all it’s dependencies.</li>
  <li>outputDir - output directory for generated java source files</li>
  <li>inputFileOrDir - file name of a Pegasus data schema file, a directory containing Pegasus data schema files, or a fully qualified schema name</li>
</ul>

<h2 id="generate-rest-model-idl">Generate Rest Model IDL</h2>
<p>Serializes a set of resource models to a RESTspec IDL file.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java -cp &lt;CLASSPATH&gt; com.linkedin.restli.tools.idlgen.RestLiResourceModelExporterCmdLineApp \
  -outdir &lt;outputDirPath&gt; -sourcepath &lt;sourcePath&gt; -resourcepackages &lt;resourcePackages&gt;
</code></pre></div></div>

<ul>
  <li>CLASSPATH - ‘com.linkedin.pegasus:restli-tools:[CURRENT_VERSION]’ artifact and all it’s dependencies.  Compiled classes within the java packages referred to by ‘resourcePackages’</li>
  <li>outputDirPath - Directory in which to output the generated IDL files (default=current working dir)</li>
  <li>sourcePath - Space-delimited list of directories in which to find resource Java source files</li>
  <li>resourcePackages - Space-delimited list of packages to scan for resource classes</li>
</ul>

<p>Build integration: assembly (creation of jar) should depend on this task.  This task depends on compilation of classes within the java packages referred to by ‘resourcePackages’.</p>

<h2 id="validate-and-publish-idl">Validate and Publish IDL</h2>
<p>Copies IDL (.restspec.json) files to client module and check backwards compatibility between pairs of idl (.restspec.json) files. The check result messages are categorized.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java [-Dgenerator.resolver.path=&lt;dataSchemaRelativePath&gt;] -cp CLASSPATH \
  com.linkedin.restli.tools.idlcheck.RestLiResourceModelCompatibilityChecker \
  [--compat OFF|IGNORE|BACKWARDS|EQUIVALENT] [pairs of &lt;prevRestspecPath currRestspecPath&gt;]
</code></pre></div></div>

<ul>
  <li>dataSchemaRelativePath - Path to .pdsc files required by the interface definition (e.g.  /src/main/pegasus).</li>
  <li>CLASSPATH - ‘com.linkedin.pegasus:restli-tools:[CURRENT_VERSION]’ artifact and all it’s dependencies.</li>
  <li>prevRestspecPath -</li>
  <li>currRestspecPath -</li>
</ul>

<p>Build integration: assembly (creation of jar) should depend on this task.  If compatibility checker passes, all .restspec.json files should be copied from the server module to the module where client bindings are generated.  This task depends on the ‘Generate Rest Model IDL’ task.  A property named ‘rest.model.compatibility’ should be overridable by the developer (allowing them to set it to ‘ignore’ or ‘backwards’) and should default to ‘equivalent’ if they do not provide it.</p>

<h2 id="rest-client-generation">Rest Client Generation</h2>
<p>Generates Java request builders from Rest.li idl.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java [-Dgenerator.resolver.path=&lt;dataSchemaRelativePath&gt;] \
     [-Dgenerator.rest.generate.datatemplates=&lt;true|false&gt;] \
  -cp &lt;CLASSPATH&gt; com.linkedin.restli.tools.clientgen.RestRequestBuilderGenerator \
  &lt;targetDirectoryPath&gt; [&lt;sourceFileOrDir&gt; ...]
</code></pre></div></div>

<ul>
  <li>dataSchemaRelativePath - Path to .pdsc files required by the interface definition.</li>
  <li>generator.rest.generate.datatemplates - false unless task should also generate java data template bindings</li>
  <li>CLASSPATH - ‘com.linkedin.pegasus:restli-tools:[CURRENT_VERSION]’ artifact and all it’s dependencies.</li>
  <li>targetDirectoryPath - path to target root java source directory</li>
  <li>sourceFileOrDir - paths to IDL files or directories</li>
</ul>

<p>Build integration: Compilation of java source should depend on this task.</p>

<h2 id="config-build-script">Config Build Script</h2>

<p>To construct these build tasks, it can help to add a utility task that constructs a list of all the source paths used for ‘data template generation’, ‘avro schema generation’, ‘rest model generation’ and ‘rest client generation’.</p>

<h2 id="clean-generated">Clean Generated</h2>

<p>No java class for this.  All directories written to by ‘data template generation’, ‘avro schema generation’, ‘rest model generation’ and ‘rest client generation’ should be deleted.</p>

<p>Build integration: clean task should depend on this</p>

                     </div>
                     <!-- <div class="col l3">
                            <div class="row">
                                    <div class="col l12">
                                      <div class="card blue-grey darken-1">
                                        <div class="card-content white-text">
                                          <span class="card-title">Card Title</span>
                                          <p>I am a very simple card. I am good at containing small bits of information.
                                          I am convenient because I require little markup to use effectively.</p>
                                        </div>
                                        <div class="card-action">
                                          <a href="#">This is a link</a>
                                          <a href="#">This is a link</a>
                                        </div>
                                      </div>
                                    </div>
                                  </div>
                     </div> -->
                   </div>
</div>



      <footer class="page-footer">
    <div class="container">
      <div class="row">
        <div class="col s6">
          <h5>Rest.li</h5>
          <p class="text-lighten-4">Rest.li is an open source REST framework for building robust, scalable RESTful architectures using type-safe bindings and asynchronous, non-blocking IO. Rest.li fills a niche for applying RESTful principles at scale with an end-to-end developer workflow for building REST APIs, which promotes clean REST practices, uniform interface design and consistent data modeling.</p>
        </div>
        <div class="col s5 offset-s1">
          <h5 class="black-text">Community</h5>
          <ul>
              <li>Github <a class="" href="https://github.com/linkedin/rest.li">Rest.li</a></li>
              <li>Linkedin <a class="" href="http://www.linkedin.com/groups/Restli-4855943">Rest.li Group</a></li>
            <li>Follow us on twitter: <a class="" href="https://twitter.com/rest_li"> @rest_li</a></li>
            <li>Issue Tracking: <a class="" href="https://github.com/linkedin/rest.li/issues">github issue tracking</a></li>
          </ul>
        </div>
      </div>
    </div>
    <div class="footer-copyright">
        <div class="container">
            <div>
                <span style="text-align: right; float: left">
                Copyright © 2018. Powered by <a target="_blank" href="http://jekyllrb.com/" class="black-text text-lighten-3">Jekyll</a>
                </span> 
            </div>
        </div>  
    </div>
</footer>
      
    <!--  Scripts-->                                                                               
<script src="/js/jquery.min.js"></script>
<script src="/js/materialize.min.js"></script>
<script src="/js/init.js"></script>

  </body>

</html>
