* "Summary":#summary
* "About Unstructured Data":#about
* "Features Overview":#features
* "Unstructured Data Resources":#create
** "Base Resource Interfaces":#base
** "Working with Streaming Resources":#stream
*** "Resource Definition":#stream-def
*** "Download/Get API":#stream-get
** "Working with Non-Streaming Resources":#nonstream
*** "Resource Definition":#nonstream-def
*** "Download/Get API":#nonstream-get
* "Consume Unstructured Data":#consume
** "Unstructured Data Response":#response
** "Basic Http Client":#basic
** "D2 Client":#d2
** "Error Handlings":#error
* "FAQs":#faq

<a id="summary"></a>

h1. Summary

Rest.li applications are built around *Resources*. The key ingredient to creating a resource is _data model_, whose internal structure is defined by "Pegasus Data Schema":/linkedin/rest.li/wiki/DATA-Data-Schema-and-Templates in key-values style. A fundamental presumption was that such structure exists for every Rest.li data model. However, it's not the case for _unstructured_ data such as images or PDFs, which are usually consumed in raw binary forms without a containing data structure.

This user guide is about working with _unstructured data_ in Rest.li framework. This is _not_ a comprehensive guide to building Rest.li resources in general, which is already covered in great details at "Rest.li User Guide":https://github.com/linkedin/rest.li/wiki/Rest.li-User-Guide#writing-resources. This guide focuses on the differences of unstructured data resource.

<a id="about"></a>

h1. About Unstructured Data

To Rest.li, the key difference about unstructured data is that they don't have any defined schema and don't have to be represented by a single generated class in Rest.li like schema-base data does (RecordTemplate). Unstructured data can be handled in the rawest form as a bytes array or a more advanced form as InputStream/ByteBuffer in Java for example.

Additionally, there are several other differences that set them apart from the typical structured data:

* *Different Wire Protocol.* Rest.li transports _structured_ data as JSON content. But _unstructured_ data should be transported in their own MIME type with the body contains only the binaries.
* *Larger Data Size.* Unstructured data are usually larger in sheer size. Buffering the entire payload in system memory may not be a good idea and not as necessary as for structured data (in order for the codec to work).
* *Different Data Handling.* Application logic is much less likely to have reasons to peek into or even mutate unstructured data on the fly. Once the data is minted or fetched, they should remain immutable during transportation. (except maybe for special handling like compression/decompression which is taken care by the framework anyway)
* *Different Types of Client.* The query for unstructured data is usually initiated by end-user clients in some native manner. A good example is that a web browser could initiate a binary upload/download without invoking any JavaScript logic.
* *Breakable.* Unstructured data can be broken down and processed as a series of byte chunks. This is perfect for streaming which is necessary to reduce the memory footprint.

<a id="features"></a>

h1. Features Overview

By default, unstructured data enjoys the same level of support as structured data in Rest.li: they can be modeled as various resource types and most resource-supporting features and tooling should work. *However*, because of the lack of RecordTemplate-based data model, any feature that works on the structure of the resource value, such as Field Projections, Entity Validation etc, do _not_ apply to unstructured data resources, although they will continue to work with structured data resources that live in the same Rest.li application.

*Features Highlights:*

* Model as Collection, Association or Simple (Singleton) with both Sync and Async I/O
* Model as sub-resource of structured data resources
* Download/Get Method (w. Post/Upload, Put and Delete supports coming)
* Rest.li and R2 Filters
* Unstructured Data Streaming
* Generated Rest APIs documentation (limited)

*Not Supported Features:*

* Model as Action or Free-Form resource
* Model as parent-resource
* APIs of BATCH_*, FINDERS, PARTIAL_UPDATES
* Field projections (skipped)
* Decoration

*Streaming Support*

In this context, _streaming_ means the ability to transport and process _unstructured data_ in small chunks without the need to buffering the whole content in memory. It sounds appealing, but it introduces complexities for the app developers that might be unnecessary in most simple use cases. Therefore, Rest.li supports both non-streaming and streaming method.

<a id="create"></a>

h1. Unstructured Data Resources

<a id="base"></a>

h2. Base Resource Interfaces

Base interface determines the resource type, the resource key and value type. Unstructured data has its own set of base interfaces. The main difference is the absence of the resource value type. Each resource type has two variants: Non-Streaming and Streaming version. Non-streaming comes with synchronous and asynchronous style, while there is no such distinction for streaming.

*Non-Streaming base interfaces*
* Collection
** @UnstructuredDataCollectionResource@
** Async
*** @UnstructuredDataCollectionResourceAsync@
*** @UnstructuredDataCollectionResourceTask@
*** @UnstructuredDataCollectionResourcePromise@
* Association
** @UnstructuredDataAssociationResource@
** Async
*** @UnstructuredDataAssociationResourceAsync@
*** @UnstructuredDataAssociationResourceTask@
*** @UnstructuredDataAssociationResourcePromise@
* Simple
** @UnstructuredDataSimpleResource@
** Async
*** @UnstructuredDataSimpleResourceAsync@
*** @UnstructuredDataSimpleResourceTask@
*** @UnstructuredDataSimpleResourcePromise@

*Streaming base interfaces*
* @UnstructuredDataCollectionResourceReactive@
* @UnstructuredDataAssociationResourceReactive@ 
* @UnstructuredDataSimpleResourceReactive@ 

<a id="stream"></a>

h2. Working with Streaming Resources

*Highlights:*
* Streaming resources are _relatively_ more complicated to write, maintain and debug. It's only recommended if the context demands higher performance and end-to-end streaming is indeed _achievable_. Still, performance gain with using streaming is not guaranteed. Benchmarking is the best way to tell. 
* Creating a streaming resource doesn't automatically make it end-to-end streaming across network nodes. It only guarantees that no buffering will happen within the Rest.li application that host this resource. For example, the data source must provide a way to allow partial data fetching, same to the other end: the destination node must be able to consume the data partially.
* Rest.li streaming adapts the "Flow reactive streaming":https://community.oracle.com/docs/DOC-1006738 interfaces introduced in Java 9. Rest.li maintains its own local copy to avoid the dependency at this moment.

<a id="stream-def"></a>

h3. Resource Definition

The definition of streaming unstructured data resource is similar to a regular resource. However, no value type is needed.

```java
@RestLiCollection(name = "resumes", namespace = "com.mycompany")
public class ResumesResource extends UnstructuredDataCollectionResourceReactiveTemplate<String> { ... }
```

<a id="stream-get"></a>

h3. Download/Get API

The interface of streaming resource is similar to the "asynchronous resources":/wiki/Rest.li-User-Guide#asynchronous-resources with a callback parameter that's used to return the result.

```java
@Override
public void get(String resumeId, @CallbackParam Callback<UnstructuredDataReactiveResult> callback) {
    Publisher<ByteString> publisher = new ResumeDataPublisher(resumeId);
    UnstructuredDataReactiveResult result = new UnstructuredDataReactiveResult(publisher, "application/pdf");
    callback.onSuccess(result);
}
```

*Get Response*

_UnstructuredDataReactiveResult_ represents the download response which encapsulates the unstructured data publisher as well as the metadata needed to return a successful response. Its merely a container and could be subclassed if desires.

*Writing Unstructured Data*

Streaming requires the data to be read/write in continuous chunks manner. Simple bytes array or InputStream won't do the job. Rest.li adopt the "Reactive Streaming":http://reactive-streams.org standard and the "Flow":https://community.oracle.com/docs/DOC-1006738 interfaces introduced in Java 9. Refer to their documentation for more details.

ByteString is essentially Rest.li's immutable bytes array implementation and is used here to represent a single _chunk_. "Publisher":https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.Publisher.html is the interface that provides the chunks when they are requested. Note that the chunk size is not enforced, however, it's recommended to make the size reasonable and consistent.

*Writing Unstructured Data w. R2 Writer*

Rest.li's R2 layer has its own Reactive Streaming implementation that is somewhat similar to Java 9's Flow. If a writer is already provided, it can be easily converted to Publisher using the provided FlowBridge util. 

```java
Writer dataWriter = new ResumeDataWriter(id);
Publisher<ByteString> dataPublisher = FlowBridge.toPublisher(dataWriter);
```

*Setting the Content-Type*

A content-specific "MIME content-type":https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types is required for the unstructured response to be handled correctly by its clients. It is required as part of the _UnstructuredDataReactiveResult_ and is used _as it-is_ in the HTTP response header. No validation is done by Rest.li.

*Setting Additional Headers*

More headers/metadata can be set using the ResourceContext. Here is an example to add a 'disposition' header to the response:

```java
getContext().setResponseHeader("Content-Disposition", "attachment; filename=\"filename.jpg\"");
```

<a id="nonstream"></a>

h2. Working with Non-Streaming Resources

*Highlights:*

* Non-streaming is a better choice for use cases that have lighter traffic and simpler network topology.
* Unlike the streaming counterpart, non-streaming resources has distinct synchronous and asynchronous interface. Generally, the async interface is recommended for larger data with longer initial fetch. For details on what to choose, refers to the main user guide.

<a id="nonstream-def"></a>

h3. Resource Definition

This defines an unstructured data resource with a synchronous interface.

```java
@RestLiCollection(name = "resumes", namespace = "com.mycompany")
public class ResumesResource extends CollectionUnstructuredDataResourceTemplate<String> {...}
```

<a id="nonstream-get"></a>

h3. Download/Get API

```java
public void get(String resumeId, @UnstructuredDataWriterParam UnstructuredDataWriter writer) {
  byte[] resumeData = fetchResumeDataFromSource(resumeId);
  writer.setContentType("application/pdf");
  writer.getOutputStream().write(resumeData);
}
```

*Get Response*

_UnstructuredDataWriter_ encapsulates the Get response and an instance of it is provided by the framework in the form of Get parameter _@UnstructuredDataWriterParam_.

*Writing Unstructured Data*

To return an unstructured data, simply write its raw bytes to the _OutputStream_ provided by the _UnstructuredDataWriter_ instance. All content should be written to the _OutputStream_ before Get method returns. Otherwise, an incomplete response could be sent.

*Warn*: Don't write to the @OutputStream@ asynchronously, use one of the asynchronous interfaces.

```java
@RestLiCollection(name = "resumes", namespace = "com.mycompany")
public class ResumesResource extends UnstructuredDataCollectionResourceAsyncTemplate<String> {
  public void get(String resumeId, @UnstructuredDataWriterParam UnstructuredDataWriter writer, Callback<Void> callback) {
    fetchResumeDataFromSource(resumeId, new Callback<ByteString>() {
      public onSuccess(ByteString resumeData) {
        writer.setContentType("application/pdf");
        writer.getOutputStream().write(resumeData);
        callback.onSuccess(null);
      }
      ...
    });
  }
}
```

*Setting the Content-Type*

@UnstructuredDataWriter@ provides a setter for the content-type of unstructured data. It is recommended to set the Content-Type before writing any data to the OutputStream. This allows potential optimization to be done in the future: For example, Rest.li could start sending the response without waiting for all the content to be written (and that might require the Content-Type in the header).

<a id="filter"></a>

h2. Rest.li Filters and Unstructured Data

Rest.li "filters":https://github.com/linkedin/rest.li/wiki/Rest.li-Filters currently don't support access to the unstructured data payload. Any existing or new filter that tries to access the payload will get an empty record. (No, they won't just fail.)

<a id="idl"></a>

h2. Resource IDL for Unstructured Data

Resource IDLs are also generated for unstructured data resources, with a few minor differences in the generated IDL and Restspec files:

* A new "entityType" field to indicate the resource entity type being UNSTRUCTURED_DATA
* The existing "schema" field is empty when the "entityType" field is UNSTRUCTURED_DATA

<a id="doc"></a>

h2. Online Documentation

Rest.li generates online "API documentation":https://github.com/linkedin/rest.li/wiki/Rest.li-User-Guide#online-documentation for every resource. It also works for unstructured data resource, however, in the API page, unstructured data is currently treated as an empty missing model.

<a id="consume"></a>

h1. Consume Unstructured Data

*Highlights*
* Unstructured data resources are designed to be invoked by any HTTP client natively without the need of decoding/unwrapping by a _rich client_ like Rest.li's RestClient. In fact, no request builders are generated at all for unstructured data resources. 
* Use a D2 client directly for use cases that need the dynamic host feature from RestClient.

<a id="response"></a>

h2. Response Anatomy

A simple unstructured data GET response:

```sh
curl 'http://myhost/resumes/1'

HTTP/1.1 200 OK
Content-Type: application/pdf
Content:
<<< bytes >>>
```

<a id="http"></a>

h2. Using an Http Client

One common Http client is a native browser (not the JavaScript client _lives_ in a browser). Unstructured data resource endpoints can be used in place wherever a standard web resource link is expected.

```html
<html>
  <a src="http://myhost/resumes/1">Download Resume</a>
</html>
```

<a id="d2"></a>

h2. Using a D2 Client

"D2":https://github.com/linkedin/rest.li/wiki/Dynamic-Discovery is what powers the host finding capability of RestClient under the hood. With a "D2 client":https://github.com/linkedin/rest.li/wiki/D2-Quickstart-Tutorial#step-3-create-a-client, you can send a request without having to specify the actual hostname of your resources:

```java
URI uri = URI.create("d2://resumes/1");
StreamRequest req = new StreamRequestBuilder(uri).build(...);
d2Client.streamRequest(req, responseCallback)
...
```

<a id="error"></a>

h2. Error Handlings

A request to unstructured data resource could fail in the "same ways":https://github.com/linkedin/rest.li/wiki/Rest.li-User-Guide#returning-errors a regular resource does. Moreover, even when a request such as Get is successful, the data flow could still be interrupted or timeout. When that happens, you could receive a successful HTTP status like 200 and still get an incomplete response or long hanging that results in a client timeout.

<a id="faq"></a>

h1. FAQs

* *Q: Is there a size limit on how large an unstructured data could be served by Rest.li resource?*
A: No. But practically, the size will be cap base on your server's timeout value. If you are seeing incompleted content on the client, it could be caused by an undersize server timeout value.

* *Q: What should be a reasonable server timeout?*
A: It depends on if the Rest.li application hosts a mix of structured and unstructured resources. Currently, Rest.li only allow one timeout setting for the entire app. You may not want a long timeout for APIs that serve small structured data. On the other hand, a short timeout for APIs that serve large unstructured data.

* *Q: Should I create a streaming or non-streaming resource for my unstructured data?*
A: First of all, streaming doesn't come for free and true end-to-end streaming also depends on your other nodes in the network, so make sure you understand what you are getting into. Secondly, the performance depends on many factors such as the size of the data and I/O performances etc.

* *Q: What is reactive streaming and how can I leverage it?*
A: The idea of _reactive streaming_ is a set of interfaces that work together in a way that very similar to how the Publisher/scriber design pattern works, except that the data are polled by Subscribers, instead of pushed by Publishers. There are several implementations and Rest.li adapts the one from Java 9 Flow. It can be leveraged as long as you can provide the implementation, e.g. a Publisher capable of fetching data partially from the _source_ (whatever it is, local and remote) on demand.
