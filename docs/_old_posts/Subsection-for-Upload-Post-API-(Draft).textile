h3. Upload/Post API (Streaming)

The interface of streaming resource is similar to the "asynchronous resources":/wiki/Rest.li-User-Guide#asynchronous-resources with a callback parameter that's used to return the result.

T

```java
@Override
public void create(Publisher<ByteString> publisher, Callback<CreateResponse> callback) {
  Subscriber<ByteString> subscriber = MySubscriber(callback);
  publisher.subscribe(subscriber);
}
```

*Create Response*

The standard _CreateResponse_ represents the response of the uploading.

*Reading Unstructured Data*

Streaming requires the data to be read/write in continuous chunks manner. Simple bytes array or InputStream won't do the job. Rest.li adopt the "Reactive Streaming":http://reactive-streams.org standard and the "Flow":https://community.oracle.com/docs/DOC-1006738 interfaces introduced in Java 9. Refer to their documentation for more details.

ByteString is essentially Rest.li's immutable bytes array implementation and is used here to represent a single _chunk_. "Subscriber":https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.Subscriber.html requests for chunks when the resource is ready to consume data. Asynchronously, a number of chunks (determined by the data Publisher) will be received by this subscriber at a later time.

*Reading Unstructured Data w. R2 Reader*

Rest.li's R2 layer has its own Reactive Streaming implementation that is somewhat similar to Java 9's Flow. If a reader is already provided, it can be easily converted to Subscriber using the provided FlowBridge util. 

```java
Reader reader = new ResumeReader(id);
Subscriber<ByteString> subscriber = FlowBridge.toSubscriber(reader);
publisher.subscribe(subscriber);
```

h3. Upload/Get API (Non-Streaming)

```java
public CreateResponse create(@UnstructuredDataReaderParam UnstructuredDataReader reader) {
  byte[] resumeData = reader.getInputStream().readAll();
  String contentType = reader.getContentType();
  writeToDB(resumeData, contentType);
  return new CreateResponse(200, "Done");
}
```